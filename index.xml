<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Thanh HV's Blog</title><link>https://thanhhv.github.io/</link><description>Recent content on Thanh HV's Blog</description><generator>Hugo -- 0.146.7</generator><language>en-us</language><lastBuildDate>Sun, 05 Oct 2025 10:50:00 +0700</lastBuildDate><atom:link href="https://thanhhv.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Những điều mình học được về Index trong MongoDB</title><link>https://thanhhv.github.io/posts/index-mongodb/</link><pubDate>Sun, 05 Oct 2025 10:50:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/index-mongodb/</guid><description>&lt;p>Khi làm việc với MongoDB, chắc hẳn bạn đã nghe đến &lt;strong>index&lt;/strong> - một khái niệm tưởng đơn giản nhưng lại có ảnh hưởng rất lớn đến hiệu năng của hệ thống.&lt;br>
Nếu không hiểu rõ cách hoạt động của index, bạn có thể khiến truy vấn chậm đi đáng kể, hoặc tốn nhiều tài nguyên mà không biết lý do.&lt;/p>
&lt;p>Trong bài viết này, mình sẽ chia sẻ một cách dễ hiểu nhất về &lt;strong>index trong MongoDB&lt;/strong>: nó là gì, tại sao cần dùng, có những loại nào và hoạt động ra sao.&lt;/p></description></item><item><title>Triển khai microservice với GraphQL Federation</title><link>https://thanhhv.github.io/posts/graphql-federation/</link><pubDate>Mon, 22 Sep 2025 21:10:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/graphql-federation/</guid><description>&lt;p>Trong quá trình làm việc, team mình từng triển khai một hệ thống microservice với hơn &lt;strong>20 service&lt;/strong> hoạt động độc lập. Để kết nối các service này vào một API thống nhất cho client sử dụng, bọn mình đã áp dụng &lt;strong>GraphQL Federation&lt;/strong>.&lt;/p>
&lt;p>Bài viết này sẽ chia sẻ lại cách tiếp cận đó — cách mà Federation giúp gom nhiều service lại thành một &lt;strong>GraphQL API&lt;/strong> duy nhất, đơn giản cho phía client nhưng vẫn linh hoạt cho backend.&lt;/p></description></item><item><title>Bộ nguyên tắc SOLID trong lập trình là gì? (Phiên bản kiếp hiệp)</title><link>https://thanhhv.github.io/posts/solid/</link><pubDate>Wed, 10 Sep 2025 15:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/solid/</guid><description>&lt;p>Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về &lt;strong>SOLID&lt;/strong> nhé.&lt;/p></description></item><item><title>PostgreSQL xử lý câu lệnh DML như thế nào?</title><link>https://thanhhv.github.io/posts/postgresql-fundamental/</link><pubDate>Sun, 07 Sep 2025 23:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/postgresql-fundamental/</guid><description>&lt;p>Khi làm việc với database chắc hẳn chúng ta đã quen với các câu lệnh như &lt;code>SELECT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>INSERT&lt;/code>, &lt;code>DELETE&lt;/code>,&amp;hellip;&lt;br>
Giả sử khi chạy một câu lệnh &lt;code>INSERT INTO ...&lt;/code> để thêm record vào DB thì bên trong cơ sở dữ liệu sẽ làm những gì để xử lý?&lt;br>
Trong bài viết này, hãy cùng mình tìm hiểu đằng sau một câu lệnh SQL khi thực thi sẽ đi qua những bước gì nhé.&lt;/p></description></item><item><title>Lập kế hoạch công việc hiệu quả với SMART</title><link>https://thanhhv.github.io/posts/smart/</link><pubDate>Fri, 29 Aug 2025 21:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/smart/</guid><description>&lt;p>Chắc hẳn bạn đã quá quen thuộc với việc làm việc trong các team theo các mô hình quản lý như &lt;strong>Agile&lt;/strong>, đặc biệt là trong các công ty lớn. Vì vậy hôm nay mình sẽ chia sẻ cho các bạn cách có thể làm việc hiệu quả hơn khi muốn đóng góp nhiều hơn vào các buổi planning, muốn nhận được đánh giá tốt hơn từ team, hoặc khi các bạn làm cho startup nơi đòi hỏi nỗ lực cá nhân cao do thiếu hụt về resource.&lt;br>
Đó chính là &lt;strong>lập kế hoạch theo quy tắc &lt;code>SMART&lt;/code>&lt;/strong>.&lt;/p></description></item><item><title>Designing a virtual tag module in FinOps</title><link>https://thanhhv.github.io/posts/virtual-tag-in-finops/</link><pubDate>Sun, 17 Aug 2025 10:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/virtual-tag-in-finops/</guid><description>&lt;p>Khi làm việc với các hệ thống FinOps thì có 2 thứ quan trọng chúng ta cần phải quan tâm đó chính là &lt;strong>perspective&lt;/strong>, thứ 2 là &lt;strong>showback và chargeback&lt;/strong>. Trong bài viết này mình sẽ chia sẻ lại tại sao chúng quan trọng và làm sao để có thể dễ dàng quản lý chúng bằng module &lt;strong>virtual tag&lt;/strong> trong các hệ thống FinOps.&lt;/p>
&lt;p>Bắt đầu nào, dĩ nhiên là ngoài những cái này ra thì FinOps cũng có rất nhiều thứ quan trọng cần phải chú ý nhưng ở đây ta chỉ nói về những cái này thôi nhé.&lt;/p></description></item><item><title>Kubernetes Components</title><link>https://thanhhv.github.io/posts/kubernetes-components/</link><pubDate>Sun, 29 Jun 2025 08:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/kubernetes-components/</guid><description>&lt;p>&lt;img alt="K8s component" loading="lazy" src="https://thanhhv.github.io/posts/kubernetes-components/k8s-components.png">&lt;/p>
&lt;p>The architecture of Kubernetes is divided into two main parts:&lt;/p>
&lt;h2 id="1-control-plane-components">1. Control Plane Components&lt;/h2>
&lt;p>The Control Plane is the &lt;strong>brain of Kubernetes&lt;/strong> — responsible for managing the overall state of the cluster and orchestrating all activities.&lt;/p>
&lt;h3 id="11-kube-apiserver">1.1 kube-apiserver&lt;/h3>
&lt;ul>
&lt;li>Acts as the central communication gateway of the system.&lt;/li>
&lt;li>All requests from &lt;code>kubectl&lt;/code>, the Dashboard, CI/CD pipelines, etc., are sent through this component.&lt;/li>
&lt;li>Responsible for:
&lt;ul>
&lt;li>Authentication&lt;/li>
&lt;li>Authorization&lt;/li>
&lt;li>Reading/writing data from/to &lt;code>etcd&lt;/code>&lt;/li>
&lt;li>Forwarding requests to other components&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Example:&lt;br>
You run &lt;code>kubectl get pods&lt;/code> → the request goes to the kube-apiserver.&lt;/p></description></item><item><title>Kubernetes Concepts</title><link>https://thanhhv.github.io/posts/kubernetes-concept/</link><pubDate>Sun, 29 Jun 2025 08:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/kubernetes-concept/</guid><description>&lt;p>When learning Kubernetes, there are two core concepts you should understand: &lt;strong>Kubernetes Object Model&lt;/strong> and &lt;strong>Declarative Management&lt;/strong>. Let&amp;rsquo;s break down both of these.&lt;/p>
&lt;p>&lt;img alt="K8s concept" loading="lazy" src="https://thanhhv.github.io/posts/kubernetes-concept/k8s-concept.png">&lt;/p>
&lt;h2 id="1-kubernetes-object-model">1. Kubernetes Object Model&lt;/h2>
&lt;p>Everything in Kubernetes is an &lt;strong>object&lt;/strong>, and these objects are managed via YAML or JSON definitions. They represent the resources in your system.&lt;/p>
&lt;h3 id="cluster">Cluster&lt;/h3>
&lt;p>A &lt;strong>cluster&lt;/strong> is a group of machines (nodes) consisting of:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Control Plane (master)&lt;/strong> - responsible for managing the system.&lt;/li>
&lt;li>&lt;strong>Worker Nodes&lt;/strong> - where your applications run.&lt;/li>
&lt;/ul>
&lt;h3 id="node">Node&lt;/h3>
&lt;p>A &lt;strong>node&lt;/strong> is a physical or virtual machine within a cluster.&lt;br>
Each node includes:&lt;/p></description></item><item><title>Google Cloud Billing</title><link>https://thanhhv.github.io/posts/google-cloud-billing/</link><pubDate>Tue, 24 Jun 2025 13:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/google-cloud-billing/</guid><description>&lt;p>&lt;img alt="gg-billing" loading="lazy" src="https://thanhhv.github.io/posts/google-cloud-billing/gg-billing.png">&lt;/p>
&lt;p>In Google Cloud, &lt;strong>Billing&lt;/strong> is the system that helps you manage &lt;strong>costs, payments, and budgets&lt;/strong> when using services on Google Cloud Platform (GCP), such as Compute Engine, BigQuery, Cloud Storage, and more. Below are the four most important components in Google Cloud Billing:&lt;/p>
&lt;h2 id="1-budget">1. Budget&lt;/h2>
&lt;ul>
&lt;li>Allows you to set a &lt;strong>spending limit&lt;/strong> for a specific time period (e.g., month, quarter) for a project or billing account.&lt;/li>
&lt;li>&lt;strong>Purpose:&lt;/strong> Avoid spending beyond your planned budget.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> You&amp;rsquo;re building a backend for a crawling system running on GCP, using multiple VMs or Cloud Functions. To control cost, you set a &lt;strong>$500/month&lt;/strong> budget to track your expenses.&lt;/li>
&lt;/ul>
&lt;h2 id="2-alert">2. Alert&lt;/h2>
&lt;ul>
&lt;li>Alerts are &lt;strong>automatically triggered&lt;/strong> when spending exceeds a defined percentage of the budget (e.g., 50%, 90%, 100%).&lt;/li>
&lt;li>&lt;strong>Purpose:&lt;/strong> Notify you when costs spike unexpectedly — possibly due to a bug or misconfiguration.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> If the cost of your backend on Cloud Run reaches &lt;strong>90% of the $500 budget&lt;/strong>, you’ll receive an email notification to take action.&lt;/li>
&lt;/ul>
&lt;p>&lt;img alt="budget-alert" loading="lazy" src="https://thanhhv.github.io/posts/google-cloud-billing/budget-alert.png">&lt;/p></description></item><item><title>Google Cloud Compute Offering</title><link>https://thanhhv.github.io/posts/google-cloud-compute-offering/</link><pubDate>Mon, 23 Jun 2025 13:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/google-cloud-compute-offering/</guid><description>&lt;p>In Google Cloud, &lt;strong>Compute Offering&lt;/strong> is a set of services that help you run workloads (like applications, APIs, batch jobs, etc.) on Google&amp;rsquo;s host infrastructure. Depending on your workload and requirements, you can choose from the options below:&lt;/p>
&lt;p>&lt;img alt="gg-cloud-comute-offering" loading="lazy" src="https://thanhhv.github.io/posts/google-cloud-compute-offering/gg-compute-offering.png">&lt;/p>
&lt;h2 id="1-compute-engine-iaas---infrastructure-as-a-service">1. Compute Engine (IaaS - Infrastructure as a Service)&lt;/h2>
&lt;ul>
&lt;li>A virtual machine where you have full permission to configure the environment.&lt;/li>
&lt;li>High level of control, similar to traditional hosting on the cloud.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Configure OS in detail, install custom software, need full system control.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run a Node.js/Golang server, cron job, or backend AI model training.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> EC2&lt;/li>
&lt;/ul>
&lt;h2 id="2-app-engine-paas---platform-as-a-service">2. App Engine (PaaS - Platform as a Service)&lt;/h2>
&lt;ul>
&lt;li>A platform for running applications where you only need to deploy code — Google handles everything else (scaling, patching, infrastructure, etc.).&lt;/li>
&lt;li>Low level of control — just push your code, no need to manage servers.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Rapid development, no infrastructure management needed.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run a small API server, REST API, or MVP web app.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> Elastic Beanstalk&lt;/li>
&lt;/ul>
&lt;h2 id="3-cloud-run-serverless-containers">3. Cloud Run (Serverless Containers)&lt;/h2>
&lt;ul>
&lt;li>Run containers (e.g., Docker) in a serverless model. Billing is based on request duration.&lt;/li>
&lt;li>Medium level of control — you manage the container image, while Google handles scaling and infrastructure.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Leverage the benefits of containers + serverless for lightweight backends or microservices.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run an API service, webhook receiver, or AI inference container.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> App Runner / Fargate&lt;/li>
&lt;/ul>
&lt;h2 id="4-google-kubernetes-engine-gke-caas---container-as-a-service">4. Google Kubernetes Engine (GKE) (CaaS - Container as a Service)&lt;/h2>
&lt;ul>
&lt;li>Run containerized applications with Kubernetes. Google manages the control plane.&lt;/li>
&lt;li>High level of control — you can fully configure your cluster, while Google manages some parts of it.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Need orchestration, CI/CD pipelines, or complex multi-service applications.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run a microservices system, CI job runners, or real-time data pipelines.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> EKS&lt;/li>
&lt;/ul>
&lt;h2 id="5-cloud-functions-faas---function-as-a-service">5. Cloud Functions (FaaS - Function as a Service)&lt;/h2>
&lt;ul>
&lt;li>Write and deploy small functions that are triggered by events (HTTP, Pub/Sub, Cloud Storage, etc.).&lt;/li>
&lt;li>Extremely easy to use — just write a function, no need to manage infrastructure.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Handle small event-driven logic, time-based triggers, or system integration tasks.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Auto-resize images, handle webhooks from Telegram/Stripe, send emails on user registration.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> Lambda&lt;/li>
&lt;/ul></description></item><item><title>Bloom filter là gì và trường hợp sử dụng</title><link>https://thanhhv.github.io/posts/bloom-filter/</link><pubDate>Sat, 24 May 2025 20:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/bloom-filter/</guid><description>&lt;p>Chào mọi người, hôm nay trong lúc mình ôn tập kiến thức thì nhớ đến Bloom Filter, thế là mình lại phải viết thêm một bài nói về cái này nữa rồi =))&lt;/p>
&lt;p>&lt;strong>Bloom Filter&lt;/strong> là một cấu trúc dữ liệu xác suất được thiết kế để kiểm tra nhanh chóng xem một phần tử có thuộc tập hợp hay không.&lt;/p>
&lt;p>Công dụng của nó là kiểm tra nhanh xem &lt;em>&amp;ldquo;Cái này có chưa nhỉ?&amp;rdquo;&lt;/em>&lt;/p></description></item><item><title>Tổng quan về Hợp đồng Thông minh trong DEX và AMM</title><link>https://thanhhv.github.io/posts/dex/</link><pubDate>Sun, 18 May 2025 16:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/dex/</guid><description>&lt;h2 id="hợp-đồng-thông-minh-dex">Hợp đồng thông minh DEX&lt;/h2>
&lt;p>Trong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: &lt;strong>Factory&lt;/strong>, &lt;strong>Router&lt;/strong>, và &lt;strong>Pair&lt;/strong>. Vai trò của từng hợp đồng như sau:&lt;/p>
&lt;h3 id="-1-factory-contract">🔹 1. Factory Contract&lt;/h3>
&lt;ul>
&lt;li>Là nơi đăng ký chính của các pool thanh khoản (cặp token).&lt;/li>
&lt;li>Tạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới.&lt;/li>
&lt;li>Lưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Các hàm chính:&lt;/strong>&lt;/p></description></item><item><title>So sánh Node.js và Golang trong Backend</title><link>https://thanhhv.github.io/posts/nodejs-vs-go/</link><pubDate>Sat, 17 May 2025 19:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/nodejs-vs-go/</guid><description>&lt;p>Xin chào mọi người,&lt;/p>
&lt;p>Trong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có &lt;strong>Node.js&lt;/strong> và &lt;strong>Golang&lt;/strong>. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let&amp;rsquo;s start!&lt;/p>
&lt;p>&lt;img alt="Nodejs-vs-Golang" loading="lazy" src="https://thanhhv.github.io/posts/nodejs-vs-go/nodejs-go.png">&lt;/p>
&lt;hr>
&lt;h3 id="1-hiệu-năng-và-đa-luồng">1. Hiệu năng và Đa luồng&lt;/h3>
&lt;p>&lt;strong>Golang&lt;/strong> có hiệu năng tốt hơn nhờ là compiled language và mô hình &lt;strong>goroutine&lt;/strong> rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.&lt;/p></description></item><item><title>Xác thực người dùng bằng ví crypto</title><link>https://thanhhv.github.io/posts/verify-user-wallet/</link><pubDate>Sun, 11 May 2025 20:40:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/verify-user-wallet/</guid><description>&lt;p>Hôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,&amp;hellip;). Cùng bắt đầu nhé! Quá trình này gồm &lt;strong>3 bước đơn giản&lt;/strong>:&lt;/p></description></item><item><title>Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain "đổi ý"</title><link>https://thanhhv.github.io/posts/reorg-in-blockchain/</link><pubDate>Sat, 10 May 2025 23:44:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/reorg-in-blockchain/</guid><description>&lt;h2 id="1-cơ-bản-về-cách-blockchain-thêm-block">1. Cơ bản về cách blockchain thêm block&lt;/h2>
&lt;p>Các blockchain như Ethereum, Bitcoin hoạt động như sau:&lt;/p>
&lt;ul>
&lt;li>Mỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại.&lt;/li>
&lt;li>Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng.&lt;/li>
&lt;li>Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình.&lt;/li>
&lt;/ul>
&lt;p>Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.&lt;br>
Giả sử mạng lưới đang dừng ở block thứ &lt;code>99&lt;/code>. Miner A tìm ra block &lt;code>100A&lt;/code> và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block &lt;code>100B&lt;/code> và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.&lt;/p></description></item><item><title>SQL vs NoSQL</title><link>https://thanhhv.github.io/posts/mongodb-vs-postgresql/</link><pubDate>Wed, 23 Apr 2025 20:44:51 +0700</pubDate><guid>https://thanhhv.github.io/posts/mongodb-vs-postgresql/</guid><description>&lt;p>Xin chào các bạn,&lt;/p>
&lt;p>Trong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là &lt;strong>SQL&lt;/strong> và &lt;strong>NoSQL&lt;/strong>, cụ thể là &lt;strong>PostgreSQL&lt;/strong> và &lt;strong>MongoDB&lt;/strong>. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.&lt;/p></description></item><item><title>Welcome</title><link>https://thanhhv.github.io/posts/welcome/</link><pubDate>Wed, 23 Apr 2025 20:23:52 +0700</pubDate><guid>https://thanhhv.github.io/posts/welcome/</guid><description>&lt;p>🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at &lt;strong>thanhhv.github.io&lt;/strong>. Stay tuned for more!&lt;/p></description></item><item><title>Curriculum Vitae</title><link>https://thanhhv.github.io/cv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://thanhhv.github.io/cv/</guid><description>&lt;h2 id="-hoang-van-thanh---software-engineer">👨‍💻 Hoang Van Thanh - Software Engineer&lt;/h2>
&lt;ul>
&lt;li>📍 Thu Duc, Ho Chi Minh City, Vietnam&lt;/li>
&lt;li>📧 Email: &lt;a href="mailto:thanhhv317@gmail.com">thanhhv317@gmail.com&lt;/a>&lt;/li>
&lt;li>🐙 GitHub: &lt;a href="https://github.com/thanhhv">@thanhhv&lt;/a>&lt;/li>
&lt;li>🔗 LinkedIn: &lt;a href="https://www.linkedin.com/in/thanhhv317/">linkedin.com/in/thanhhv317&lt;/a>&lt;/li>
&lt;li>📅 DOB: 11/08/1998&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="-skills">🛠 Skills&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Languages &amp;amp; Frameworks&lt;/strong>: Node.js (NestJS, Express), Go, TypeScript, JavaScript, REST API, GraphQL, gRPC&lt;/li>
&lt;li>&lt;strong>Architecture&lt;/strong>: Microservices, Message Queue, Clean Architecture, WebSocket&lt;/li>
&lt;li>&lt;strong>Databases&lt;/strong>: PostgreSQL, MongoDB, Meilisearch, Redis&lt;/li>
&lt;li>&lt;strong>Blockchain&lt;/strong>: Web3.js, ethers, On-chain Data&lt;/li>
&lt;li>&lt;strong>DevOps &amp;amp; Tools&lt;/strong>: Docker, AWS (EC2, S3, Lambda, SQS), Linux, GitHub Actions (CI/CD)&lt;/li>
&lt;li>&lt;strong>Testing &amp;amp; Monitoring&lt;/strong>: Jest, Prometheus, Grafana, Jaeger, Tracing&lt;/li>
&lt;li>&lt;strong>Frontend&lt;/strong>: React.js, HTML, CSS, Bootstrap&lt;/li>
&lt;li>&lt;strong>Methodologies&lt;/strong>: Agile/Scrum&lt;/li>
&lt;li>&lt;strong>Soft Skills&lt;/strong>: Problem solving, Teamwork &amp;amp; Collaboration, Planning &amp;amp; Task Management&lt;/li>
&lt;li>&lt;strong>Languages&lt;/strong>: English&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="-experience">💼 Experience&lt;/h3>
&lt;h4 id="cloudverse-052025---082025--senior-backend-engineer-contractor">Cloudverse (05/2025 - 08/2025) — Senior Backend Engineer (Contractor)&lt;/h4>
&lt;p>&lt;strong>Project: Cloud Provider&lt;/strong> — Management platform for partner list using FinOps system&lt;/p></description></item><item><title>Go-live load test &amp; deployment checklist</title><link>https://thanhhv.github.io/wiki/go-live-checklist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://thanhhv.github.io/wiki/go-live-checklist/</guid><description>&lt;blockquote>
&lt;p>🎯 &lt;strong>Goal:&lt;/strong> Ensure the system is stable, scalable, and production-ready before launching.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="-i-code--functional">🧱 I. CODE &amp;amp; FUNCTIONAL&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Code reviewed and approved by at least one senior developer&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Unit test coverage ≥ 80%&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Edge cases handled properly&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> No N+1 queries (GraphQL/ORM optimized)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> No leftover &lt;code>console.log&lt;/code> or &lt;code>debugger&lt;/code> in code&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> No secrets or tokens hardcoded&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-ii-cicd--deployment">🚦 II. CI/CD &amp;amp; DEPLOYMENT&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> CI pipeline set up (build → test → deploy)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Rollback plan in place (script or quick revert strategy)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Staging/UAT environment available and tested&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> &lt;code>.env&lt;/code> variables configured correctly (not copied from local)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Proper branch/tag naming (e.g. &lt;code>release/v1.0.0&lt;/code>)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-iii-security">🔒 III. SECURITY&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Auth applied on all sensitive routes (JWT, OAuth, API keys)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Role &amp;amp; permission system tested&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> No publicly exposed sensitive endpoints (&lt;code>/admin&lt;/code>, &lt;code>/debug&lt;/code>)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Checked for XSS, SQLi, path traversal vulnerabilities&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Rate limiting/throttling in place for public APIs&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Security headers enabled (&lt;code>helmet&lt;/code>, CORS, etc.)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-iv-performance--scaling">📈 IV. PERFORMANCE &amp;amp; SCALING&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Load tested for target RPS (e.g. ≥ 10k req/s)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Concurrent users simulated (e.g. 1k logins)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> DB indexed properly (&lt;code>EXPLAIN ANALYZE&lt;/code> used)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Redis, CDN, or in-memory caching applied&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> File/media offloaded to external storage (e.g. S3)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> API only returns necessary data (REST/GraphQL select)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-v-monitoring--alerting">🧠 V. MONITORING &amp;amp; ALERTING&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Logging integrated (Winston, Pino, ELK, Datadog, etc.)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Logs include traceId, userId, route context&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Metrics collection: Prometheus / Grafana / OpenTelemetry&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Alert configured for:
&lt;ul>
&lt;li>High error rate (5xx)&lt;/li>
&lt;li>CPU &amp;gt; 80%&lt;/li>
&lt;li>Memory full&lt;/li>
&lt;li>Queue backlog increasing&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-vi-infrastructure">⚙️ VI. INFRASTRUCTURE&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Load balancer configured and stable&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Auto-restart and healthcheck ready (PM2, Docker, k8s readiness)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Database backup and restore tested&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Horizontal scaling/pod autoscaling set up if using k8s&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> &lt;code>.env.production&lt;/code> encrypted or managed via Vault&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-vii-other">📋 VII. OTHER&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Changelog written (&lt;code>CHANGELOG.md&lt;/code>)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Release announcement sent to relevant teams&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Post-deploy checklist created (Smoke test UI/API)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> QA checklist completed (login, checkout, error, etc.)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Graceful fallback UI for error handling&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> &lt;code>/status&lt;/code>, &lt;code>/health&lt;/code>, &lt;code>/metrics&lt;/code>, &lt;code>/version&lt;/code> endpoints ready&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-ready-to-go-live">✅ READY TO GO LIVE?&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Goal&lt;/th>
&lt;th>Ready?&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Code clean and stable&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Load test passed&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Monitoring in place&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Rollback plan confirmed&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Stakeholders notified&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="-post-go-live-actions">🔁 POST GO-LIVE ACTIONS&lt;/h2>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Real-time system monitoring active&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> User feedback monitored&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Latency/error rate observed&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 24h go-live report or postmortem (if needed)&lt;/li>
&lt;/ul></description></item><item><title>Non-Tech Books Worth Reading</title><link>https://thanhhv.github.io/wiki/non-tech-books-worth-reading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://thanhhv.github.io/wiki/non-tech-books-worth-reading/</guid><description>&lt;p>Reading is not only for fun, but also to develop clear thinking and deeper perspective.&lt;br>
Here&amp;rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.&lt;/p>
&lt;h2 id="-psychology--thinking">📘 Psychology &amp;amp; Thinking&lt;/h2>
&lt;ul>
&lt;li>&lt;em>Thinking, Fast and Slow&lt;/em> - Daniel Kahneman&lt;/li>
&lt;li>&lt;em>The One Thing&lt;/em> - Gary W. Keller, Jay Papasan&lt;/li>
&lt;/ul>
&lt;h2 id="-philosophy--life">🌍 Philosophy &amp;amp; Life&lt;/h2>
&lt;ul>
&lt;li>&lt;em>Naval Ravikant: Để thịnh vượng và hạnh phúc&lt;/em> - Eric Jorgenson&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&amp;hellip; will be updated more&lt;/p></description></item></channel></rss>
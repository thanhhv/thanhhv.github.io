<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Thanh HV's Blog</title>
<meta name=keywords content><meta name=description content="Posts - Thanh HV's Blog"><meta name=author content><link rel=canonical href=https://thanhhv.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.36ab24e4c1b924360adfc391166b0e8914323d9d6ffa42a50f9c6c435c5e1831.css integrity="sha256-Nqsk5MG5JDYK38ORFmsOiRQyPZ1v+kKlD5xsQ1xeGDE=" rel="preload stylesheet" as=style><link rel=icon href=https://thanhhv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thanhhv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://thanhhv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://thanhhv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://thanhhv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://thanhhv.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://thanhhv.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://thanhhv.github.io/posts/"><meta property="og:site_name" content="Thanh HV's Blog"><meta property="og:title" content="Posts"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://thanhhv.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://thanhhv.github.io/ accesskey=h title="Thanh HV's Blog (Alt + H)">Thanh HV's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://thanhhv.github.io/ title=Home><span>Home</span></a></li><li><a href=https://thanhhv.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://thanhhv.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://thanhhv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://thanhhv.github.io/cv/ title=CV><span>CV</span></a></li><li><a href=https://thanhhv.github.io/wiki/ title=Wiki><span>Wiki</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://thanhhv.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Triển khai microservice với graphQL federation</h2></header><div class=entry-content><p>Tổng quan Hôm nay mình muốn chia sẻ một cách tiếp cận mà team mình đã áp dụng khi triển khai một hệ thống microservice với hơn 20 service, trong đó mỗi service đều hoạt động độc lập.
Bài viết này sẽ giới thiệu cách sử dụng GraphQL Federation để kết nối các service đó vào một API GraphQL thống nhất, giúp client truy vấn dữ liệu dễ dàng qua một endpoint duy nhất.
...</p></div><footer class=entry-footer><span title='2025-09-22 21:10:00 +0700 +07'>September 22, 2025</span>&nbsp;·&nbsp;6 min</footer><a class=entry-link aria-label="post link to Triển khai microservice với graphQL federation" href=https://thanhhv.github.io/posts/graphql-federation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bộ nguyên tắc SOLID trong lập trình là gì? (Phiên bản kiếp hiệp)</h2></header><div class=entry-content><p>Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về SOLID nhé.
...</p></div><footer class=entry-footer><span title='2025-09-10 15:00:00 +0700 +07'>September 10, 2025</span>&nbsp;·&nbsp;8 min</footer><a class=entry-link aria-label="post link to Bộ nguyên tắc SOLID trong lập trình là gì? (Phiên bản kiếp hiệp)" href=https://thanhhv.github.io/posts/solid/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PostgreSQL xử lý câu lệnh DML như thế nào?</h2></header><div class=entry-content><p>Khi làm việc với database chắc hẳn chúng ta đã quen với các câu lệnh như SELECT, UPDATE, INSERT, DELETE,…
Giả sử khi chạy một câu lệnh INSERT INTO ... để thêm record vào DB thì bên trong cơ sở dữ liệu sẽ làm những gì để xử lý?
Trong bài viết này, hãy cùng mình tìm hiểu đằng sau một câu lệnh SQL khi thực thi sẽ đi qua những bước gì nhé.
...</p></div><footer class=entry-footer><span title='2025-09-07 23:00:00 +0700 +07'>September 7, 2025</span>&nbsp;·&nbsp;6 min</footer><a class=entry-link aria-label="post link to PostgreSQL xử lý câu lệnh DML như thế nào?" href=https://thanhhv.github.io/posts/postgresql-fundamental/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lập kế hoạch công việc hiệu quả với SMART</h2></header><div class=entry-content><p>Chắc hẳn bạn đã quá quen thuộc với việc làm việc trong các team theo các mô hình quản lý như Agile, đặc biệt là trong các công ty lớn. Vì vậy hôm nay mình sẽ chia sẻ cho các bạn cách có thể làm việc hiệu quả hơn khi muốn đóng góp nhiều hơn vào các buổi planning, muốn nhận được đánh giá tốt hơn từ team, hoặc khi các bạn làm cho startup nơi đòi hỏi nỗ lực cá nhân cao do thiếu hụt về resource.
Đó chính là lập kế hoạch theo quy tắc SMART.
...</p></div><footer class=entry-footer><span title='2025-08-29 21:00:00 +0700 +07'>August 29, 2025</span>&nbsp;·&nbsp;6 min</footer><a class=entry-link aria-label="post link to Lập kế hoạch công việc hiệu quả với SMART" href=https://thanhhv.github.io/posts/smart/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Designing a virtual tag module in FinOps</h2></header><div class=entry-content><p>Khi làm việc với các hệ thống FinOps thì có 2 thứ quan trọng chúng ta cần phải quan tâm đó chính là perspective, thứ 2 là showback và chargeback. Trong bài viết này mình sẽ chia sẻ lại tại sao chúng quan trọng và làm sao để có thể dễ dàng quản lý chúng bằng module virtual tag trong các hệ thống FinOps.
Bắt đầu nào, dĩ nhiên là ngoài những cái này ra thì FinOps cũng có rất nhiều thứ quan trọng cần phải chú ý nhưng ở đây ta chỉ nói về những cái này thôi nhé.
...</p></div><footer class=entry-footer><span title='2025-08-17 10:00:00 +0700 +07'>August 17, 2025</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to Designing a virtual tag module in FinOps" href=https://thanhhv.github.io/posts/virtual-tag-in-finops/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes Components</h2></header><div class=entry-content><p>The architecture of Kubernetes is divided into two main parts:
1. Control Plane Components The Control Plane is the brain of Kubernetes — responsible for managing the overall state of the cluster and orchestrating all activities.
1.1 kube-apiserver Acts as the central communication gateway of the system. All requests from kubectl, the Dashboard, CI/CD pipelines, etc., are sent through this component. Responsible for: Authentication Authorization Reading/writing data from/to etcd Forwarding requests to other components Example:
You run kubectl get pods → the request goes to the kube-apiserver.
...</p></div><footer class=entry-footer><span title='2025-06-29 08:00:00 +0700 +07'>June 29, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Kubernetes Components" href=https://thanhhv.github.io/posts/kubernetes-components/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes Concepts</h2></header><div class=entry-content><p>When learning Kubernetes, there are two core concepts you should understand: Kubernetes Object Model and Declarative Management. Let’s break down both of these.
1. Kubernetes Object Model Everything in Kubernetes is an object, and these objects are managed via YAML or JSON definitions. They represent the resources in your system.
Cluster A cluster is a group of machines (nodes) consisting of:
Control Plane (master) - responsible for managing the system. Worker Nodes - where your applications run. Node A node is a physical or virtual machine within a cluster.
Each node includes:
...</p></div><footer class=entry-footer><span title='2025-06-29 08:00:00 +0700 +07'>June 29, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Kubernetes Concepts" href=https://thanhhv.github.io/posts/kubernetes-concept/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Google Cloud Billing</h2></header><div class=entry-content><p>In Google Cloud, Billing is the system that helps you manage costs, payments, and budgets when using services on Google Cloud Platform (GCP), such as Compute Engine, BigQuery, Cloud Storage, and more. Below are the four most important components in Google Cloud Billing:
1. Budget Allows you to set a spending limit for a specific time period (e.g., month, quarter) for a project or billing account. Purpose: Avoid spending beyond your planned budget. Example: You’re building a backend for a crawling system running on GCP, using multiple VMs or Cloud Functions. To control cost, you set a $500/month budget to track your expenses. 2. Alert Alerts are automatically triggered when spending exceeds a defined percentage of the budget (e.g., 50%, 90%, 100%). Purpose: Notify you when costs spike unexpectedly — possibly due to a bug or misconfiguration. Example: If the cost of your backend on Cloud Run reaches 90% of the $500 budget, you’ll receive an email notification to take action. ...</p></div><footer class=entry-footer><span title='2025-06-24 13:00:00 +0700 +07'>June 24, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Google Cloud Billing" href=https://thanhhv.github.io/posts/google-cloud-billing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Google Cloud Compute Offering</h2></header><div class=entry-content><p>In Google Cloud, Compute Offering is a set of services that help you run workloads (like applications, APIs, batch jobs, etc.) on Google’s host infrastructure. Depending on your workload and requirements, you can choose from the options below:
1. Compute Engine (IaaS - Infrastructure as a Service) A virtual machine where you have full permission to configure the environment. High level of control, similar to traditional hosting on the cloud. Use case: Configure OS in detail, install custom software, need full system control. Example: Run a Node.js/Golang server, cron job, or backend AI model training. AWS equivalent: EC2 2. App Engine (PaaS - Platform as a Service) A platform for running applications where you only need to deploy code — Google handles everything else (scaling, patching, infrastructure, etc.). Low level of control — just push your code, no need to manage servers. Use case: Rapid development, no infrastructure management needed. Example: Run a small API server, REST API, or MVP web app. AWS equivalent: Elastic Beanstalk 3. Cloud Run (Serverless Containers) Run containers (e.g., Docker) in a serverless model. Billing is based on request duration. Medium level of control — you manage the container image, while Google handles scaling and infrastructure. Use case: Leverage the benefits of containers + serverless for lightweight backends or microservices. Example: Run an API service, webhook receiver, or AI inference container. AWS equivalent: App Runner / Fargate 4. Google Kubernetes Engine (GKE) (CaaS - Container as a Service) Run containerized applications with Kubernetes. Google manages the control plane. High level of control — you can fully configure your cluster, while Google manages some parts of it. Use case: Need orchestration, CI/CD pipelines, or complex multi-service applications. Example: Run a microservices system, CI job runners, or real-time data pipelines. AWS equivalent: EKS 5. Cloud Functions (FaaS - Function as a Service) Write and deploy small functions that are triggered by events (HTTP, Pub/Sub, Cloud Storage, etc.). Extremely easy to use — just write a function, no need to manage infrastructure. Use case: Handle small event-driven logic, time-based triggers, or system integration tasks. Example: Auto-resize images, handle webhooks from Telegram/Stripe, send emails on user registration. AWS equivalent: Lambda</p></div><footer class=entry-footer><span title='2025-06-23 13:00:00 +0700 +07'>June 23, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Google Cloud Compute Offering" href=https://thanhhv.github.io/posts/google-cloud-compute-offering/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bloom filter là gì và trường hợp sử dụng</h2></header><div class=entry-content><p>Chào mọi người, hôm nay trong lúc mình ôn tập kiến thức thì nhớ đến Bloom Filter, thế là mình lại phải viết thêm một bài nói về cái này nữa rồi =))
Bloom Filter là một cấu trúc dữ liệu xác suất được thiết kế để kiểm tra nhanh chóng xem một phần tử có thuộc tập hợp hay không.
Công dụng của nó là kiểm tra nhanh xem “Cái này có chưa nhỉ?”
...</p></div><footer class=entry-footer><span title='2025-05-24 20:00:00 +0700 +07'>May 24, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Bloom filter là gì và trường hợp sử dụng" href=https://thanhhv.github.io/posts/bloom-filter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tổng quan về Hợp đồng Thông minh trong DEX và AMM</h2></header><div class=entry-content><p>Hợp đồng thông minh DEX Trong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: Factory, Router, và Pair. Vai trò của từng hợp đồng như sau:
🔹 1. Factory Contract Là nơi đăng ký chính của các pool thanh khoản (cặp token). Tạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới. Lưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng. Các hàm chính:
...</p></div><footer class=entry-footer><span title='2025-05-18 16:00:00 +0700 +07'>May 18, 2025</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to Tổng quan về Hợp đồng Thông minh trong DEX và AMM" href=https://thanhhv.github.io/posts/dex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>So sánh Node.js và Golang trong Backend</h2></header><div class=entry-content><p>Xin chào mọi người,
Trong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có Node.js và Golang. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let’s start!
1. Hiệu năng và Đa luồng Golang có hiệu năng tốt hơn nhờ là compiled language và mô hình goroutine rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.
...</p></div><footer class=entry-footer><span title='2025-05-17 19:00:00 +0700 +07'>May 17, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to So sánh Node.js và Golang trong Backend" href=https://thanhhv.github.io/posts/nodejs-vs-go/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Xác thực người dùng bằng ví crypto</h2></header><div class=entry-content><p>Hôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,…). Cùng bắt đầu nhé! Quá trình này gồm 3 bước đơn giản:
...</p></div><footer class=entry-footer><span title='2025-05-11 20:40:00 +0700 +07'>May 11, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Xác thực người dùng bằng ví crypto" href=https://thanhhv.github.io/posts/verify-user-wallet/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain "đổi ý"</h2></header><div class=entry-content><p>1. Cơ bản về cách blockchain thêm block Các blockchain như Ethereum, Bitcoin hoạt động như sau:
Mỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại. Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng. Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình. Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.
Giả sử mạng lưới đang dừng ở block thứ 99. Miner A tìm ra block 100A và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block 100B và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.
...</p></div><footer class=entry-footer><span title='2025-05-10 23:44:00 +0700 +07'>May 10, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label='post link to Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain "đổi ý"' href=https://thanhhv.github.io/posts/reorg-in-blockchain/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQL vs NoSQL</h2></header><div class=entry-content><p>Xin chào các bạn,
Trong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là SQL và NoSQL, cụ thể là PostgreSQL và MongoDB. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.
...</p></div><footer class=entry-footer><span title='2025-04-23 20:44:51 +0700 +07'>April 23, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to SQL vs NoSQL" href=https://thanhhv.github.io/posts/mongodb-vs-postgresql/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Welcome</h2></header><div class=entry-content><p>🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at thanhhv.github.io. Stay tuned for more!</p></div><footer class=entry-footer><span title='2025-04-23 20:23:52 +0700 +07'>April 23, 2025</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Welcome" href=https://thanhhv.github.io/posts/welcome/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://thanhhv.github.io/>Thanh HV's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
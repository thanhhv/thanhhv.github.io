<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Thanh HV's Blog</title><link>https://thanhhv.github.io/posts/</link><description>Recent content in Posts on Thanh HV's Blog</description><generator>Hugo -- 0.146.7</generator><language>en-us</language><lastBuildDate>Mon, 22 Sep 2025 21:10:00 +0700</lastBuildDate><atom:link href="https://thanhhv.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Triển khai microservice với graphQL federation</title><link>https://thanhhv.github.io/posts/graphql-federation/</link><pubDate>Mon, 22 Sep 2025 21:10:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/graphql-federation/</guid><description>&lt;h1 id="tổng-quan">Tổng quan&lt;/h1>
&lt;p>Hôm nay mình muốn chia sẻ một cách tiếp cận mà team mình đã áp dụng khi triển khai một hệ thống microservice với hơn 20 service, trong đó mỗi service đều hoạt động độc lập.&lt;/p>
&lt;p>Bài viết này sẽ giới thiệu cách sử dụng GraphQL Federation để kết nối các service đó vào &lt;strong>một API GraphQL thống nhất&lt;/strong>, giúp client truy vấn dữ liệu dễ dàng qua một endpoint duy nhất.&lt;/p></description></item><item><title>Bộ nguyên tắc SOLID trong lập trình là gì? (Phiên bản kiếp hiệp)</title><link>https://thanhhv.github.io/posts/solid/</link><pubDate>Wed, 10 Sep 2025 15:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/solid/</guid><description>&lt;p>Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về &lt;strong>SOLID&lt;/strong> nhé.&lt;/p></description></item><item><title>PostgreSQL xử lý câu lệnh DML như thế nào?</title><link>https://thanhhv.github.io/posts/postgresql-fundamental/</link><pubDate>Sun, 07 Sep 2025 23:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/postgresql-fundamental/</guid><description>&lt;p>Khi làm việc với database chắc hẳn chúng ta đã quen với các câu lệnh như &lt;code>SELECT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>INSERT&lt;/code>, &lt;code>DELETE&lt;/code>,&amp;hellip;&lt;br>
Giả sử khi chạy một câu lệnh &lt;code>INSERT INTO ...&lt;/code> để thêm record vào DB thì bên trong cơ sở dữ liệu sẽ làm những gì để xử lý?&lt;br>
Trong bài viết này, hãy cùng mình tìm hiểu đằng sau một câu lệnh SQL khi thực thi sẽ đi qua những bước gì nhé.&lt;/p></description></item><item><title>Lập kế hoạch công việc hiệu quả với SMART</title><link>https://thanhhv.github.io/posts/smart/</link><pubDate>Fri, 29 Aug 2025 21:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/smart/</guid><description>&lt;p>Chắc hẳn bạn đã quá quen thuộc với việc làm việc trong các team theo các mô hình quản lý như &lt;strong>Agile&lt;/strong>, đặc biệt là trong các công ty lớn. Vì vậy hôm nay mình sẽ chia sẻ cho các bạn cách có thể làm việc hiệu quả hơn khi muốn đóng góp nhiều hơn vào các buổi planning, muốn nhận được đánh giá tốt hơn từ team, hoặc khi các bạn làm cho startup nơi đòi hỏi nỗ lực cá nhân cao do thiếu hụt về resource.&lt;br>
Đó chính là &lt;strong>lập kế hoạch theo quy tắc &lt;code>SMART&lt;/code>&lt;/strong>.&lt;/p></description></item><item><title>Designing a virtual tag module in FinOps</title><link>https://thanhhv.github.io/posts/virtual-tag-in-finops/</link><pubDate>Sun, 17 Aug 2025 10:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/virtual-tag-in-finops/</guid><description>&lt;p>Khi làm việc với các hệ thống FinOps thì có 2 thứ quan trọng chúng ta cần phải quan tâm đó chính là &lt;strong>perspective&lt;/strong>, thứ 2 là &lt;strong>showback và chargeback&lt;/strong>. Trong bài viết này mình sẽ chia sẻ lại tại sao chúng quan trọng và làm sao để có thể dễ dàng quản lý chúng bằng module &lt;strong>virtual tag&lt;/strong> trong các hệ thống FinOps.&lt;/p>
&lt;p>Bắt đầu nào, dĩ nhiên là ngoài những cái này ra thì FinOps cũng có rất nhiều thứ quan trọng cần phải chú ý nhưng ở đây ta chỉ nói về những cái này thôi nhé.&lt;/p></description></item><item><title>Kubernetes Components</title><link>https://thanhhv.github.io/posts/kubernetes-components/</link><pubDate>Sun, 29 Jun 2025 08:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/kubernetes-components/</guid><description>&lt;p>&lt;img alt="K8s component" loading="lazy" src="https://thanhhv.github.io/posts/kubernetes-components/k8s-components.png">&lt;/p>
&lt;p>The architecture of Kubernetes is divided into two main parts:&lt;/p>
&lt;h2 id="1-control-plane-components">1. Control Plane Components&lt;/h2>
&lt;p>The Control Plane is the &lt;strong>brain of Kubernetes&lt;/strong> — responsible for managing the overall state of the cluster and orchestrating all activities.&lt;/p>
&lt;h3 id="11-kube-apiserver">1.1 kube-apiserver&lt;/h3>
&lt;ul>
&lt;li>Acts as the central communication gateway of the system.&lt;/li>
&lt;li>All requests from &lt;code>kubectl&lt;/code>, the Dashboard, CI/CD pipelines, etc., are sent through this component.&lt;/li>
&lt;li>Responsible for:
&lt;ul>
&lt;li>Authentication&lt;/li>
&lt;li>Authorization&lt;/li>
&lt;li>Reading/writing data from/to &lt;code>etcd&lt;/code>&lt;/li>
&lt;li>Forwarding requests to other components&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Example:&lt;br>
You run &lt;code>kubectl get pods&lt;/code> → the request goes to the kube-apiserver.&lt;/p></description></item><item><title>Kubernetes Concepts</title><link>https://thanhhv.github.io/posts/kubernetes-concept/</link><pubDate>Sun, 29 Jun 2025 08:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/kubernetes-concept/</guid><description>&lt;p>When learning Kubernetes, there are two core concepts you should understand: &lt;strong>Kubernetes Object Model&lt;/strong> and &lt;strong>Declarative Management&lt;/strong>. Let&amp;rsquo;s break down both of these.&lt;/p>
&lt;p>&lt;img alt="K8s concept" loading="lazy" src="https://thanhhv.github.io/posts/kubernetes-concept/k8s-concept.png">&lt;/p>
&lt;h2 id="1-kubernetes-object-model">1. Kubernetes Object Model&lt;/h2>
&lt;p>Everything in Kubernetes is an &lt;strong>object&lt;/strong>, and these objects are managed via YAML or JSON definitions. They represent the resources in your system.&lt;/p>
&lt;h3 id="cluster">Cluster&lt;/h3>
&lt;p>A &lt;strong>cluster&lt;/strong> is a group of machines (nodes) consisting of:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Control Plane (master)&lt;/strong> - responsible for managing the system.&lt;/li>
&lt;li>&lt;strong>Worker Nodes&lt;/strong> - where your applications run.&lt;/li>
&lt;/ul>
&lt;h3 id="node">Node&lt;/h3>
&lt;p>A &lt;strong>node&lt;/strong> is a physical or virtual machine within a cluster.&lt;br>
Each node includes:&lt;/p></description></item><item><title>Google Cloud Billing</title><link>https://thanhhv.github.io/posts/google-cloud-billing/</link><pubDate>Tue, 24 Jun 2025 13:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/google-cloud-billing/</guid><description>&lt;p>&lt;img alt="gg-billing" loading="lazy" src="https://thanhhv.github.io/posts/google-cloud-billing/gg-billing.png">&lt;/p>
&lt;p>In Google Cloud, &lt;strong>Billing&lt;/strong> is the system that helps you manage &lt;strong>costs, payments, and budgets&lt;/strong> when using services on Google Cloud Platform (GCP), such as Compute Engine, BigQuery, Cloud Storage, and more. Below are the four most important components in Google Cloud Billing:&lt;/p>
&lt;h2 id="1-budget">1. Budget&lt;/h2>
&lt;ul>
&lt;li>Allows you to set a &lt;strong>spending limit&lt;/strong> for a specific time period (e.g., month, quarter) for a project or billing account.&lt;/li>
&lt;li>&lt;strong>Purpose:&lt;/strong> Avoid spending beyond your planned budget.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> You&amp;rsquo;re building a backend for a crawling system running on GCP, using multiple VMs or Cloud Functions. To control cost, you set a &lt;strong>$500/month&lt;/strong> budget to track your expenses.&lt;/li>
&lt;/ul>
&lt;h2 id="2-alert">2. Alert&lt;/h2>
&lt;ul>
&lt;li>Alerts are &lt;strong>automatically triggered&lt;/strong> when spending exceeds a defined percentage of the budget (e.g., 50%, 90%, 100%).&lt;/li>
&lt;li>&lt;strong>Purpose:&lt;/strong> Notify you when costs spike unexpectedly — possibly due to a bug or misconfiguration.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> If the cost of your backend on Cloud Run reaches &lt;strong>90% of the $500 budget&lt;/strong>, you’ll receive an email notification to take action.&lt;/li>
&lt;/ul>
&lt;p>&lt;img alt="budget-alert" loading="lazy" src="https://thanhhv.github.io/posts/google-cloud-billing/budget-alert.png">&lt;/p></description></item><item><title>Google Cloud Compute Offering</title><link>https://thanhhv.github.io/posts/google-cloud-compute-offering/</link><pubDate>Mon, 23 Jun 2025 13:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/google-cloud-compute-offering/</guid><description>&lt;p>In Google Cloud, &lt;strong>Compute Offering&lt;/strong> is a set of services that help you run workloads (like applications, APIs, batch jobs, etc.) on Google&amp;rsquo;s host infrastructure. Depending on your workload and requirements, you can choose from the options below:&lt;/p>
&lt;p>&lt;img alt="gg-cloud-comute-offering" loading="lazy" src="https://thanhhv.github.io/posts/google-cloud-compute-offering/gg-compute-offering.png">&lt;/p>
&lt;h2 id="1-compute-engine-iaas---infrastructure-as-a-service">1. Compute Engine (IaaS - Infrastructure as a Service)&lt;/h2>
&lt;ul>
&lt;li>A virtual machine where you have full permission to configure the environment.&lt;/li>
&lt;li>High level of control, similar to traditional hosting on the cloud.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Configure OS in detail, install custom software, need full system control.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run a Node.js/Golang server, cron job, or backend AI model training.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> EC2&lt;/li>
&lt;/ul>
&lt;h2 id="2-app-engine-paas---platform-as-a-service">2. App Engine (PaaS - Platform as a Service)&lt;/h2>
&lt;ul>
&lt;li>A platform for running applications where you only need to deploy code — Google handles everything else (scaling, patching, infrastructure, etc.).&lt;/li>
&lt;li>Low level of control — just push your code, no need to manage servers.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Rapid development, no infrastructure management needed.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run a small API server, REST API, or MVP web app.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> Elastic Beanstalk&lt;/li>
&lt;/ul>
&lt;h2 id="3-cloud-run-serverless-containers">3. Cloud Run (Serverless Containers)&lt;/h2>
&lt;ul>
&lt;li>Run containers (e.g., Docker) in a serverless model. Billing is based on request duration.&lt;/li>
&lt;li>Medium level of control — you manage the container image, while Google handles scaling and infrastructure.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Leverage the benefits of containers + serverless for lightweight backends or microservices.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run an API service, webhook receiver, or AI inference container.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> App Runner / Fargate&lt;/li>
&lt;/ul>
&lt;h2 id="4-google-kubernetes-engine-gke-caas---container-as-a-service">4. Google Kubernetes Engine (GKE) (CaaS - Container as a Service)&lt;/h2>
&lt;ul>
&lt;li>Run containerized applications with Kubernetes. Google manages the control plane.&lt;/li>
&lt;li>High level of control — you can fully configure your cluster, while Google manages some parts of it.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Need orchestration, CI/CD pipelines, or complex multi-service applications.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Run a microservices system, CI job runners, or real-time data pipelines.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> EKS&lt;/li>
&lt;/ul>
&lt;h2 id="5-cloud-functions-faas---function-as-a-service">5. Cloud Functions (FaaS - Function as a Service)&lt;/h2>
&lt;ul>
&lt;li>Write and deploy small functions that are triggered by events (HTTP, Pub/Sub, Cloud Storage, etc.).&lt;/li>
&lt;li>Extremely easy to use — just write a function, no need to manage infrastructure.&lt;/li>
&lt;li>&lt;strong>Use case:&lt;/strong> Handle small event-driven logic, time-based triggers, or system integration tasks.&lt;/li>
&lt;li>&lt;strong>Example:&lt;/strong> Auto-resize images, handle webhooks from Telegram/Stripe, send emails on user registration.&lt;/li>
&lt;li>&lt;strong>AWS equivalent:&lt;/strong> Lambda&lt;/li>
&lt;/ul></description></item><item><title>Bloom filter là gì và trường hợp sử dụng</title><link>https://thanhhv.github.io/posts/bloom-filter/</link><pubDate>Sat, 24 May 2025 20:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/bloom-filter/</guid><description>&lt;p>Chào mọi người, hôm nay trong lúc mình ôn tập kiến thức thì nhớ đến Bloom Filter, thế là mình lại phải viết thêm một bài nói về cái này nữa rồi =))&lt;/p>
&lt;p>&lt;strong>Bloom Filter&lt;/strong> là một cấu trúc dữ liệu xác suất được thiết kế để kiểm tra nhanh chóng xem một phần tử có thuộc tập hợp hay không.&lt;/p>
&lt;p>Công dụng của nó là kiểm tra nhanh xem &lt;em>&amp;ldquo;Cái này có chưa nhỉ?&amp;rdquo;&lt;/em>&lt;/p></description></item><item><title>Tổng quan về Hợp đồng Thông minh trong DEX và AMM</title><link>https://thanhhv.github.io/posts/dex/</link><pubDate>Sun, 18 May 2025 16:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/dex/</guid><description>&lt;h2 id="hợp-đồng-thông-minh-dex">Hợp đồng thông minh DEX&lt;/h2>
&lt;p>Trong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: &lt;strong>Factory&lt;/strong>, &lt;strong>Router&lt;/strong>, và &lt;strong>Pair&lt;/strong>. Vai trò của từng hợp đồng như sau:&lt;/p>
&lt;h3 id="-1-factory-contract">🔹 1. Factory Contract&lt;/h3>
&lt;ul>
&lt;li>Là nơi đăng ký chính của các pool thanh khoản (cặp token).&lt;/li>
&lt;li>Tạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới.&lt;/li>
&lt;li>Lưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Các hàm chính:&lt;/strong>&lt;/p></description></item><item><title>So sánh Node.js và Golang trong Backend</title><link>https://thanhhv.github.io/posts/nodejs-vs-go/</link><pubDate>Sat, 17 May 2025 19:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/nodejs-vs-go/</guid><description>&lt;p>Xin chào mọi người,&lt;/p>
&lt;p>Trong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có &lt;strong>Node.js&lt;/strong> và &lt;strong>Golang&lt;/strong>. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let&amp;rsquo;s start!&lt;/p>
&lt;p>&lt;img alt="Nodejs-vs-Golang" loading="lazy" src="https://thanhhv.github.io/posts/nodejs-vs-go/nodejs-go.png">&lt;/p>
&lt;hr>
&lt;h3 id="1-hiệu-năng-và-đa-luồng">1. Hiệu năng và Đa luồng&lt;/h3>
&lt;p>&lt;strong>Golang&lt;/strong> có hiệu năng tốt hơn nhờ là compiled language và mô hình &lt;strong>goroutine&lt;/strong> rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.&lt;/p></description></item><item><title>Xác thực người dùng bằng ví crypto</title><link>https://thanhhv.github.io/posts/verify-user-wallet/</link><pubDate>Sun, 11 May 2025 20:40:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/verify-user-wallet/</guid><description>&lt;p>Hôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,&amp;hellip;). Cùng bắt đầu nhé! Quá trình này gồm &lt;strong>3 bước đơn giản&lt;/strong>:&lt;/p></description></item><item><title>Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain "đổi ý"</title><link>https://thanhhv.github.io/posts/reorg-in-blockchain/</link><pubDate>Sat, 10 May 2025 23:44:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/reorg-in-blockchain/</guid><description>&lt;h2 id="1-cơ-bản-về-cách-blockchain-thêm-block">1. Cơ bản về cách blockchain thêm block&lt;/h2>
&lt;p>Các blockchain như Ethereum, Bitcoin hoạt động như sau:&lt;/p>
&lt;ul>
&lt;li>Mỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại.&lt;/li>
&lt;li>Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng.&lt;/li>
&lt;li>Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình.&lt;/li>
&lt;/ul>
&lt;p>Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.&lt;br>
Giả sử mạng lưới đang dừng ở block thứ &lt;code>99&lt;/code>. Miner A tìm ra block &lt;code>100A&lt;/code> và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block &lt;code>100B&lt;/code> và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.&lt;/p></description></item><item><title>SQL vs NoSQL</title><link>https://thanhhv.github.io/posts/mongodb-vs-postgresql/</link><pubDate>Wed, 23 Apr 2025 20:44:51 +0700</pubDate><guid>https://thanhhv.github.io/posts/mongodb-vs-postgresql/</guid><description>&lt;p>Xin chào các bạn,&lt;/p>
&lt;p>Trong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là &lt;strong>SQL&lt;/strong> và &lt;strong>NoSQL&lt;/strong>, cụ thể là &lt;strong>PostgreSQL&lt;/strong> và &lt;strong>MongoDB&lt;/strong>. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.&lt;/p></description></item><item><title>Welcome</title><link>https://thanhhv.github.io/posts/welcome/</link><pubDate>Wed, 23 Apr 2025 20:23:52 +0700</pubDate><guid>https://thanhhv.github.io/posts/welcome/</guid><description>&lt;p>🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at &lt;strong>thanhhv.github.io&lt;/strong>. Stay tuned for more!&lt;/p></description></item></channel></rss>
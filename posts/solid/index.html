<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) | Thanh HV's Blog</title>
<meta name=keywords content="solid"><meta name=description content="Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về SOLID nhé."><meta name=author content><link rel=canonical href=https://thanhhv.github.io/posts/solid/><link crossorigin=anonymous href=/assets/css/stylesheet.36ab24e4c1b924360adfc391166b0e8914323d9d6ffa42a50f9c6c435c5e1831.css integrity="sha256-Nqsk5MG5JDYK38ORFmsOiRQyPZ1v+kKlD5xsQ1xeGDE=" rel="preload stylesheet" as=style><link rel=icon href=https://thanhhv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thanhhv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://thanhhv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://thanhhv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://thanhhv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://thanhhv.github.io/posts/solid/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://thanhhv.github.io/posts/solid/"><meta property="og:site_name" content="Thanh HV's Blog"><meta property="og:title" content="SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp)"><meta property="og:description" content="Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về SOLID nhé."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-10T15:00:00+07:00"><meta property="article:modified_time" content="2025-09-10T15:00:00+07:00"><meta property="article:tag" content="Solid"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp)"><meta name=twitter:description content="Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về SOLID nhé."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://thanhhv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp)","item":"https://thanhhv.github.io/posts/solid/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp)","name":"SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp)","description":"Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về SOLID nhé.\n","keywords":["solid"],"articleBody":"Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về SOLID nhé.\n1. Truyền thuyết về SOLID trong giang hồ Trong giang hồ lập trình, có một bộ tâm pháp được gọi là SOLID, truyền rằng ai lĩnh hội được thì code ắt tinh thông, hệ thống vững chãi, mở rộng vô biên. Bộ tâm pháp này gồm năm chiêu thức, mỗi chiêu đều ẩn chứa huyền cơ:\n1. Nhất Dụng Quy Tắc (Single Responsibility Principle) Mỗi cao thủ chỉ nên luyện một môn võ công, không nên tạp luyện đủ đường. Một class chỉ nên có một trách nhiệm, như kiếm khách chỉ dùng kiếm, không thể vừa múa kiếm vừa gõ trống. Giống như Kiều Phong chỉ cần một bộ Giáng Long Thập Bát Chưởng cũng đủ để xưng bá võ lâm khiến người người nể phục.\n2. Khai Bế Quy Tắc (Open/Closed Principle) Tâm pháp cần mở rộng để thêm chiêu thức mới, nhưng không được tùy tiện thay đổi căn cơ gốc rễ. Code cho phép mở rộng nhưng hạn chế sửa đổi, như môn phái có thể thu nhận thêm đệ tử nhưng tôn chỉ tổ sư thì bất biến.\n3. Thế Thân Quy Tắc (Liskov Substitution Principle) Đệ tử xuất sư, thay thế được sư phụ, hành tẩu giang hồ không làm loạn môn pháp. Class con thay thế class cha mà không phá hỏng chương trình, như người nối nghiệp vẫn giữ trọn đạo nghĩa tông môn.\n4. Giao Diện Phân Ly Quy Tắc (Interface Segregation Principle) Bí kíp không nên viết dài dòng, bắt đệ tử học cả ngàn chiêu không cần thiết. Interface nên gọn nhẹ, tách nhỏ, ai luyện cái gì thì chỉ học đúng cái đó, tránh việc phải học cả những chiêu không dùng đến.\n5. Nghịch Hướng Quy Tắc (Dependency Inversion Principle) Cao thủ chân chính không phụ thuộc vào vũ khí tầm thường, mà nắm được đạo lý võ học. Module cấp cao không phụ thuộc trực tiếp vào cấp thấp, cả hai đều dựa trên trừu tượng. Như tướng quân cầm quân không dựa vào loại giáo mác cụ thể, mà dựa vào binh pháp.\nThế là năm chiêu tâm pháp SOLID đã bày ra. Người trong võ lâm lập trình nếu ngộ được thì đường code sẽ như giang sơn vững chắc, dễ sửa đổi, dễ mở rộng, không sợ bug tà đạo quấy nhiễu.\nVà cho đến ngày nay, trải qua hàng trăm năm tuổi, bộ tâm pháp ấy vẫn còn lưu giữ được những giá trị bền vững. Dẫu thời thế đã đổi thay, cục diện Nam Đế Bắc Cái, Đông Tà Tây Độc đã khép lại, thì thời đại của những anh hùng bàn phím (lập trình viên) lại xuất hiện. Và ta sẽ tiếp tục nói về cách ứng dụng của SOLID trong lập trình.\n2. Chi tiết về SOLID SOLID là bộ 5 nguyên tắc thiết kế hướng đối tượng giúp code dễ bảo trì, mở rộng và giảm phụ thuộc lẫn nhau.\n2.1 Single Responsibility Principle (SRP) Ý nghĩa: Mỗi class/module chỉ nên có một lý do để thay đổi. Hiểu đơn giản: Một class chỉ làm một việc duy nhất. Ví dụ: InvoicePrinter chỉ in hóa đơn, còn tính toán hóa đơn thì để InvoiceCalculator. // ❌ Sai: Class làm quá nhiều việc class Invoice { calculateTotal() { /* logic tính toán */ } printInvoice() { /* logic in ấn */ } saveToDB() { /* logic lưu DB */ } } // ✅ Đúng: Tách ra từng trách nhiệm riêng class InvoiceCalculator { calculateTotal() { /* logic tính toán */ } } class InvoicePrinter { print(invoice: InvoiceCalculator) { /* logic in ấn */ } } class InvoiceRepository { save(invoice: InvoiceCalculator) { /* logic lưu DB */ } } 2.2 Open/Closed Principle (OCP) Ý nghĩa: Code nên mở rộng được nhưng hạn chế chỉnh sửa trực tiếp. Hiểu đơn giản: Khi có yêu cầu mới → thêm class/method thay vì sửa code cũ. Ví dụ: Thêm class mới để mở rộng tính năng thay vì chỉnh sửa class cũ. // ❌ Sai: Phải sửa code khi thêm shape mới class AreaCalculator { calculate(shape: any) { if (shape.type === \"circle\") return Math.PI * shape.radius ** 2; if (shape.type === \"square\") return shape.side ** 2; // thêm loại shape khác -\u003e phải sửa class này } } // ✅ Đúng: Mở rộng bằng cách thêm class, không sửa code cũ interface Shape { area(): number; } class Circle implements Shape { constructor(public radius: number) {} area() { return Math.PI * this.radius ** 2; } } class Square implements Shape { constructor(public side: number) {} area() { return this.side ** 2; } } class AreaCalculator { calculate(shape: Shape) { return shape.area(); } } 2.3 Liskov Substitution Principle (LSP) Ý nghĩa: Class con có thể thay thế hoàn toàn cho class cha mà không làm hỏng chương trình. Hiểu đơn giản: Nếu dùng class con mà hệ thống vẫn chạy ổn định như class cha thì mới đúng. Ví dụ: Chim sẻ có thể bay nên kế thừa “chim biết bay”, trong khi chim cánh cụt chỉ nên kế thừa “chim” chứ không nên ép vào nhóm “chim bay”. // ❌ Sai: Penguin không bay được nhưng kế thừa Bird với fly() class Bird { fly() { console.log(\"I can fly!\"); } } class Penguin extends Bird { fly() { throw new Error(\"Penguin can't fly!\"); } } // ✅ Đúng: Tách abstraction phù hợp interface Bird { eat(): void; } interface FlyingBird extends Bird { fly(): void; } class Sparrow implements FlyingBird { eat() { console.log(\"Sparrow eating\"); } fly() { console.log(\"Sparrow flying\"); } } class Penguin implements Bird { eat() { console.log(\"Penguin eating\"); } } 2.4 Interface Segregation Principle (ISP) Ý nghĩa: Interface không nên quá “béo”, class không nên bị buộc implement những thứ không dùng. Hiểu đơn giản: Chia nhỏ interface cho từng nhu cầu cụ thể. Ví dụ: Máy in chỉ cần implement IPrinter, không cần phải gánh thêm IScanner hay IFax. // ❌ Sai: Class buộc phải implement cả method không cần interface IMachine { print(): void; scan(): void; fax(): void; } class OldPrinter implements IMachine { print() { console.log(\"Printing...\"); } scan() { throw new Error(\"Not supported\"); } fax() { throw new Error(\"Not supported\"); } } // ✅ Đúng: Chia nhỏ interface interface IPrinter { print(): void; } interface IScanner { scan(): void; } interface IFax { fax(): void; } class SimplePrinter implements IPrinter { print() { console.log(\"Printing...\"); } } class MultiFunctionPrinter implements IPrinter, IScanner, IFax { print() { console.log(\"Printing...\"); } scan() { console.log(\"Scanning...\"); } fax() { console.log(\"Faxing...\"); } } 2.5 Dependency Inversion Principle (DIP) Ý nghĩa: Code nên phụ thuộc vào abstraction (interface) thay vì implementation (class cụ thể). Hiểu đơn giản: Module cấp cao không nên phụ thuộc trực tiếp module cấp thấp, cả hai nên phụ thuộc vào abstraction. Ví dụ: ReportService gọi IReportRepository thay vì fix cứng vào MySQLReportRepository. // ❌ Sai: Service phụ thuộc trực tiếp vào DB cụ thể class MySQLReportRepository { getReports() { return [\"report from MySQL\"]; } } class ReportService { constructor(private repo: MySQLReportRepository) {} showReports() { return this.repo.getReports(); } } // ✅ Đúng: Phụ thuộc abstraction (interface) interface ReportRepository { getReports(): string[]; } class MySQLReportRepository implements ReportRepository { getReports() { return [\"report from MySQL\"]; } } class MongoReportRepository implements ReportRepository { getReports() { return [\"report from MongoDB\"]; } } class ReportService { constructor(private repo: ReportRepository) {} showReports() { return this.repo.getReports(); } } // Sử dụng const service = new ReportService(new MongoReportRepository()); console.log(service.showReports()); 3. Những điều lưu ý để tránh hiểu sai về SOLID. Khi nhìn lại quy tắc SRP, có thể thấy trong NestJS (và nhiều framework khác), mỗi service (ví dụ: UserService, PostService) thường gom hết CRUD (create, read, update, delete) trong một class duy nhất. Nhìn qua có vẻ vi phạm SRP, nhưng thực tế:\nNestJS service bản chất là application service, gom logic xử lý request liên quan đến một entity/domain. Việc có createUser, updateUser, deleteUser, getUser trong cùng UserService vẫn được xem là một trách nhiệm - đó là quản lý User. Nếu tách nhỏ thành UserCreationService, UserDeletionService, UserQueryService thì số lượng file/service tăng rất nhiều, gây over-engineering cho dự án. SOLID là nguyên tắc, không phải luật cứng nhắc. Trong dự án thực tế, người ta trade-off để code dễ đọc, dễ maintain quan trọng hơn việc “theo đúng giáo trình”. Nói cách khác: không phải là không theo SOLID, mà là áp dụng nó ở mức thực dụng, tránh over-engineering.\nNgày đã dần xuống, bài viết cũng dài. Đến đây, chúc cho vị đại hiệp đọc xong bí kíp có thể vận dụng thành thạo, tung hoành giang hồ lập trình, khiến người đời hân hoan nể phục. Cáo từ.\n","wordCount":"1523","inLanguage":"en","datePublished":"2025-09-10T15:00:00+07:00","dateModified":"2025-09-10T15:00:00+07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://thanhhv.github.io/posts/solid/"},"publisher":{"@type":"Organization","name":"Thanh HV's Blog","logo":{"@type":"ImageObject","url":"https://thanhhv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://thanhhv.github.io/ accesskey=h title="Thanh HV's Blog (Alt + H)">Thanh HV's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://thanhhv.github.io/ title=Home><span>Home</span></a></li><li><a href=https://thanhhv.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://thanhhv.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://thanhhv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://thanhhv.github.io/about-me/ title="About me"><span>About me</span></a></li><li><a href=https://thanhhv.github.io/wiki/ title=Wiki><span>Wiki</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://thanhhv.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://thanhhv.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp)</h1><div class=post-meta><span title='2025-09-10 15:00:00 +0700 +07'>September 10, 2025</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><p>Hôm nay, trong một buổi chiều cuối thu ở Sài Gòn nhộn nhịp, có một chàng trai đang ngồi ôn lại kiến thức để chuẩn bị tham gia phỏng vấn trong căn nhà nhỏ. Bên ngoài cửa sổ, trời đang đổ những cơn mưa rào kèm những đợt sấm chớp lan man. Lòng ta lại suy tư về một thứ gì đó muốn được viết ra cho nhẹ nỗi lòng, thôi thì ta hãy cùng viết về <strong>SOLID</strong> nhé.</p><p><img alt=solid loading=lazy src=/posts/solid/solid.png></p><hr><h2 id=1-truyền-thuyết-về-solid-trong-giang-hồ>1. Truyền thuyết về SOLID trong giang hồ<a hidden class=anchor aria-hidden=true href=#1-truyền-thuyết-về-solid-trong-giang-hồ>#</a></h2><p>Trong giang hồ lập trình, có một bộ tâm pháp được gọi là <strong>SOLID</strong>, truyền rằng ai lĩnh hội được thì code ắt tinh thông, hệ thống vững chãi, mở rộng vô biên. Bộ tâm pháp này gồm năm chiêu thức, mỗi chiêu đều ẩn chứa huyền cơ:</p><h3 id=1-nhất-dụng-quy-tắc-single-responsibility-principle>1. Nhất Dụng Quy Tắc (Single Responsibility Principle)<a hidden class=anchor aria-hidden=true href=#1-nhất-dụng-quy-tắc-single-responsibility-principle>#</a></h3><p>Mỗi cao thủ chỉ nên luyện một môn võ công, không nên tạp luyện đủ đường. Một class chỉ nên có một trách nhiệm, như kiếm khách chỉ dùng kiếm, không thể vừa múa kiếm vừa gõ trống. Giống như Kiều Phong chỉ cần một bộ Giáng Long Thập Bát Chưởng cũng đủ để xưng bá võ lâm khiến người người nể phục.</p><p><img alt=kieuphong loading=lazy src=/posts/solid/kieuphong.png></p><h3 id=2-khai-bế-quy-tắc-openclosed-principle>2. Khai Bế Quy Tắc (Open/Closed Principle)<a hidden class=anchor aria-hidden=true href=#2-khai-bế-quy-tắc-openclosed-principle>#</a></h3><p>Tâm pháp cần mở rộng để thêm chiêu thức mới, nhưng không được tùy tiện thay đổi căn cơ gốc rễ. Code cho phép mở rộng nhưng hạn chế sửa đổi, như môn phái có thể thu nhận thêm đệ tử nhưng tôn chỉ tổ sư thì bất biến.</p><h3 id=3-thế-thân-quy-tắc-liskov-substitution-principle>3. Thế Thân Quy Tắc (Liskov Substitution Principle)<a hidden class=anchor aria-hidden=true href=#3-thế-thân-quy-tắc-liskov-substitution-principle>#</a></h3><p>Đệ tử xuất sư, thay thế được sư phụ, hành tẩu giang hồ không làm loạn môn pháp. Class con thay thế class cha mà không phá hỏng chương trình, như người nối nghiệp vẫn giữ trọn đạo nghĩa tông môn.</p><h3 id=4-giao-diện-phân-ly-quy-tắc-interface-segregation-principle>4. Giao Diện Phân Ly Quy Tắc (Interface Segregation Principle)<a hidden class=anchor aria-hidden=true href=#4-giao-diện-phân-ly-quy-tắc-interface-segregation-principle>#</a></h3><p>Bí kíp không nên viết dài dòng, bắt đệ tử học cả ngàn chiêu không cần thiết. Interface nên gọn nhẹ, tách nhỏ, ai luyện cái gì thì chỉ học đúng cái đó, tránh việc phải học cả những chiêu không dùng đến.</p><h3 id=5-nghịch-hướng-quy-tắc-dependency-inversion-principle>5. Nghịch Hướng Quy Tắc (Dependency Inversion Principle)<a hidden class=anchor aria-hidden=true href=#5-nghịch-hướng-quy-tắc-dependency-inversion-principle>#</a></h3><p>Cao thủ chân chính không phụ thuộc vào vũ khí tầm thường, mà nắm được đạo lý võ học. Module cấp cao không phụ thuộc trực tiếp vào cấp thấp, cả hai đều dựa trên trừu tượng. Như tướng quân cầm quân không dựa vào loại giáo mác cụ thể, mà dựa vào binh pháp.</p><hr><p>Thế là năm chiêu tâm pháp <strong>SOLID</strong> đã bày ra. Người trong võ lâm lập trình nếu ngộ được thì đường code sẽ như giang sơn vững chắc, dễ sửa đổi, dễ mở rộng, không sợ bug tà đạo quấy nhiễu.</p><p>Và cho đến ngày nay, trải qua hàng trăm năm tuổi, bộ tâm pháp ấy vẫn còn lưu giữ được những giá trị bền vững. Dẫu thời thế đã đổi thay, cục diện Nam Đế Bắc Cái, Đông Tà Tây Độc đã khép lại, thì thời đại của những anh hùng bàn phím (lập trình viên) lại xuất hiện. Và ta sẽ tiếp tục nói về cách ứng dụng của SOLID trong lập trình.</p><hr><h2 id=2-chi-tiết-về-solid>2. Chi tiết về SOLID<a hidden class=anchor aria-hidden=true href=#2-chi-tiết-về-solid>#</a></h2><p><strong>SOLID</strong> là bộ 5 nguyên tắc thiết kế hướng đối tượng giúp code dễ bảo trì, mở rộng và giảm phụ thuộc lẫn nhau.</p><h3 id=21-single-responsibility-principle-srp>2.1 Single Responsibility Principle (SRP)<a hidden class=anchor aria-hidden=true href=#21-single-responsibility-principle-srp>#</a></h3><ul><li><strong>Ý nghĩa:</strong> Mỗi class/module chỉ nên có một lý do để thay đổi.</li><li><strong>Hiểu đơn giản:</strong> Một class chỉ làm một việc duy nhất.</li><li><strong>Ví dụ</strong>: <code>InvoicePrinter</code> chỉ in hóa đơn, còn tính toán hóa đơn thì để <code>InvoiceCalculator</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// ❌ Sai: Class làm quá nhiều việc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Invoice</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>calculateTotal() {</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* logic tính toán */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printInvoice() {</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* logic in ấn */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>saveToDB() {</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* logic lưu DB */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ✅ Đúng: Tách ra từng trách nhiệm riêng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoiceCalculator</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>calculateTotal() {</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* logic tính toán */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoicePrinter</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>print</span>(<span style=color:#a6e22e>invoice</span>: <span style=color:#66d9ef>InvoiceCalculator</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* logic in ấn */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvoiceRepository</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>invoice</span>: <span style=color:#66d9ef>InvoiceCalculator</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* logic lưu DB */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=22-openclosed-principle-ocp>2.2 Open/Closed Principle (OCP)<a hidden class=anchor aria-hidden=true href=#22-openclosed-principle-ocp>#</a></h3><ul><li><strong>Ý nghĩa:</strong> Code nên mở rộng được nhưng hạn chế chỉnh sửa trực tiếp.</li><li><strong>Hiểu đơn giản:</strong> Khi có yêu cầu mới → thêm class/method thay vì sửa code cũ.</li><li><strong>Ví dụ:</strong> Thêm class mới để mở rộng tính năng thay vì chỉnh sửa class cũ.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// ❌ Sai: Phải sửa code khi thêm shape mới
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AreaCalculator</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>calculate</span>(<span style=color:#a6e22e>shape</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>shape</span>.<span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;circle&#34;</span>) <span style=color:#66d9ef>return</span> Math.<span style=color:#a6e22e>PI</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>shape</span>.<span style=color:#a6e22e>radius</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>shape</span>.<span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;square&#34;</span>) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>shape</span>.<span style=color:#a6e22e>side</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// thêm loại shape khác -&gt; phải sửa class này
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ✅ Đúng: Mở rộng bằng cách thêm class, không sửa code cũ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>area</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Circle</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>radius</span>: <span style=color:#66d9ef>number</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>area() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Math.<span style=color:#a6e22e>PI</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>radius</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Square</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>side</span>: <span style=color:#66d9ef>number</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>area() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>side</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AreaCalculator</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>calculate</span>(<span style=color:#a6e22e>shape</span>: <span style=color:#66d9ef>Shape</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>shape</span>.<span style=color:#a6e22e>area</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=23-liskov-substitution-principle-lsp>2.3 Liskov Substitution Principle (LSP)<a hidden class=anchor aria-hidden=true href=#23-liskov-substitution-principle-lsp>#</a></h3><ul><li><strong>Ý nghĩa:</strong> Class con có thể thay thế hoàn toàn cho class cha mà không làm hỏng chương trình.</li><li><strong>Hiểu đơn giản:</strong> Nếu dùng class con mà hệ thống vẫn chạy ổn định như class cha thì mới đúng.</li><li><strong>Ví dụ:</strong> Chim sẻ có thể bay nên kế thừa &ldquo;chim biết bay&rdquo;, trong khi chim cánh cụt chỉ nên kế thừa &ldquo;chim&rdquo; chứ không nên ép vào nhóm &ldquo;chim bay&rdquo;.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// ❌ Sai: Penguin không bay được nhưng kế thừa Bird với fly()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;I can fly!&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Penguin</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Penguin can&#39;t fly!&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ✅ Đúng: Tách abstraction phù hợp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>eat</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>FlyingBird</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sparrow</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>FlyingBird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>eat() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Sparrow eating&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fly() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Sparrow flying&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Penguin</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>Bird</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>eat() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Penguin eating&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=24-interface-segregation-principle-isp>2.4 Interface Segregation Principle (ISP)<a hidden class=anchor aria-hidden=true href=#24-interface-segregation-principle-isp>#</a></h3><ul><li><strong>Ý nghĩa:</strong> Interface không nên quá &ldquo;béo&rdquo;, class không nên bị buộc implement những thứ không dùng.</li><li><strong>Hiểu đơn giản:</strong> Chia nhỏ interface cho từng nhu cầu cụ thể.</li><li><strong>Ví dụ:</strong> Máy in chỉ cần implement <code>IPrinter</code>, không cần phải gánh thêm <code>IScanner</code> hay <code>IFax</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// ❌ Sai: Class buộc phải implement cả method không cần
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IMachine</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>print</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scan</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fax</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OldPrinter</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>IMachine</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>print() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Printing...&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scan() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Not supported&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fax() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Not supported&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ✅ Đúng: Chia nhỏ interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IPrinter</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>print</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IScanner</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scan</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IFax</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fax</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimplePrinter</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>IPrinter</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>print() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Printing...&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultiFunctionPrinter</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>IPrinter</span>, <span style=color:#a6e22e>IScanner</span>, <span style=color:#a6e22e>IFax</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>print() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Printing...&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scan() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Scanning...&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fax() {</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Faxing...&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=25-dependency-inversion-principle-dip>2.5 Dependency Inversion Principle (DIP)<a hidden class=anchor aria-hidden=true href=#25-dependency-inversion-principle-dip>#</a></h3><ul><li><strong>Ý nghĩa:</strong> Code nên phụ thuộc vào abstraction (interface) thay vì implementation (class cụ thể).</li><li><strong>Hiểu đơn giản:</strong> Module cấp cao không nên phụ thuộc trực tiếp module cấp thấp, cả hai nên phụ thuộc vào abstraction.</li><li><strong>Ví dụ:</strong> <code>ReportService</code> gọi <code>IReportRepository</code> thay vì fix cứng vào <code>MySQLReportRepository</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// ❌ Sai: Service phụ thuộc trực tiếp vào DB cụ thể
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MySQLReportRepository</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getReports() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#34;report from MySQL&#34;</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReportService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>repo</span>: <span style=color:#66d9ef>MySQLReportRepository</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>showReports() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>repo</span>.<span style=color:#a6e22e>getReports</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ✅ Đúng: Phụ thuộc abstraction (interface)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ReportRepository</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getReports</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>[];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MySQLReportRepository</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>ReportRepository</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getReports() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#34;report from MySQL&#34;</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MongoReportRepository</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>ReportRepository</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getReports() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#34;report from MongoDB&#34;</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReportService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>repo</span>: <span style=color:#66d9ef>ReportRepository</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>showReports() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>repo</span>.<span style=color:#a6e22e>getReports</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Sử dụng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>service</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ReportService</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MongoReportRepository</span>());
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>service</span>.<span style=color:#a6e22e>showReports</span>());
</span></span></code></pre></div><hr><h2 id=3-những-điều-lưu-ý-để-tránh-hiểu-sai-về-solid>3. Những điều lưu ý để tránh hiểu sai về SOLID.<a hidden class=anchor aria-hidden=true href=#3-những-điều-lưu-ý-để-tránh-hiểu-sai-về-solid>#</a></h2><p>Khi nhìn lại quy tắc <strong>SRP</strong>, có thể thấy trong NestJS (và nhiều framework khác), mỗi service (ví dụ: <code>UserService</code>, <code>PostService</code>) thường gom hết CRUD (create, read, update, delete) trong một class duy nhất. Nhìn qua có vẻ vi phạm SRP, nhưng thực tế:</p><ul><li>NestJS service bản chất là <strong>application service</strong>, gom logic xử lý request liên quan đến một entity/domain.</li><li>Việc có <code>createUser</code>, <code>updateUser</code>, <code>deleteUser</code>, <code>getUser</code> trong cùng <code>UserService</code> vẫn được xem là <strong>một trách nhiệm</strong> - đó là quản lý User.</li><li>Nếu tách nhỏ thành <code>UserCreationService</code>, <code>UserDeletionService</code>, <code>UserQueryService</code> thì số lượng file/service tăng rất nhiều, gây <strong>over-engineering</strong> cho dự án.</li><li><strong>SOLID là nguyên tắc, không phải luật cứng nhắc.</strong></li><li>Trong dự án thực tế, người ta trade-off để code <strong>dễ đọc, dễ maintain</strong> quan trọng hơn việc &ldquo;theo đúng giáo trình&rdquo;.</li></ul><blockquote><p>Nói cách khác: không phải là không theo SOLID, mà là áp dụng nó ở mức thực dụng, tránh over-engineering.</p></blockquote><hr><p>Ngày đã dần xuống, bài viết cũng dài. Đến đây, chúc cho vị đại hiệp đọc xong bí kíp có thể vận dụng thành thạo, tung hoành giang hồ lập trình, khiến người đời hân hoan nể phục. <strong>Cáo từ.</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://thanhhv.github.io/tags/solid/>Solid</a></li></ul><nav class=paginav><a class=prev href=https://thanhhv.github.io/posts/graphql-federation/><span class=title>« Prev</span><br><span>Triển khai microservice với GraphQL Federation</span>
</a><a class=next href=https://thanhhv.github.io/posts/postgresql-fundamental/><span class=title>Next »</span><br><span>PostgreSQL xử lý câu lệnh DML như thế nào?</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on x" href="https://x.com/intent/tweet/?text=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29&amp;url=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f&amp;hashtags=solid"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f&amp;title=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29&amp;summary=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29&amp;source=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f&title=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on whatsapp" href="https://api.whatsapp.com/send?text=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29%20-%20https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on telegram" href="https://telegram.me/share/url?text=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29&amp;url=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SOLID - Ngũ tuyệt trong thế giới lập trình (Phiên bản kiếp hiệp) on ycombinator" href="https://news.ycombinator.com/submitlink?t=SOLID%20-%20Ng%c5%a9%20tuy%e1%bb%87t%20trong%20th%e1%ba%bf%20gi%e1%bb%9bi%20l%e1%ba%adp%20tr%c3%acnh%20%28Phi%c3%aan%20b%e1%ba%a3n%20ki%e1%ba%bfp%20hi%e1%bb%87p%29&u=https%3a%2f%2fthanhhv.github.io%2fposts%2fsolid%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=thanhhv/blog-comments issue-term=pathname label="💬 comment" theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://thanhhv.github.io/>Thanh HV's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
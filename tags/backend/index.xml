<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Backend on Thanh HV's Blog</title><link>https://thanhhv.github.io/tags/backend/</link><description>Recent content in Backend on Thanh HV's Blog</description><generator>Hugo -- 0.146.7</generator><language>en-us</language><lastBuildDate>Sat, 17 May 2025 19:00:00 +0700</lastBuildDate><atom:link href="https://thanhhv.github.io/tags/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>So sánh Node.js và Golang trong Backend</title><link>https://thanhhv.github.io/posts/nodejs-vs-go/</link><pubDate>Sat, 17 May 2025 19:00:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/nodejs-vs-go/</guid><description>&lt;p>Xin chào mọi người,&lt;/p>
&lt;p>Trong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có &lt;strong>Node.js&lt;/strong> và &lt;strong>Golang&lt;/strong>. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let&amp;rsquo;s start!&lt;/p>
&lt;p>&lt;img alt="Nodejs-vs-Golang" loading="lazy" src="https://thanhhv.github.io/posts/nodejs-vs-go/nodejs-go.png">&lt;/p>
&lt;hr>
&lt;h3 id="1-hiệu-năng-và-đa-luồng">1. Hiệu năng và Đa luồng&lt;/h3>
&lt;p>&lt;strong>Golang&lt;/strong> có hiệu năng tốt hơn nhờ là compiled language và mô hình &lt;strong>goroutine&lt;/strong> rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.&lt;/p></description></item><item><title>Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain "đổi ý"</title><link>https://thanhhv.github.io/posts/reorg-in-blockchain/</link><pubDate>Sat, 10 May 2025 23:44:00 +0700</pubDate><guid>https://thanhhv.github.io/posts/reorg-in-blockchain/</guid><description>&lt;h2 id="1-cơ-bản-về-cách-blockchain-thêm-block">1. Cơ bản về cách blockchain thêm block&lt;/h2>
&lt;p>Các blockchain như Ethereum, Bitcoin hoạt động như sau:&lt;/p>
&lt;ul>
&lt;li>Mỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại.&lt;/li>
&lt;li>Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng.&lt;/li>
&lt;li>Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình.&lt;/li>
&lt;/ul>
&lt;p>Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.&lt;br>
Giả sử mạng lưới đang dừng ở block thứ &lt;code>99&lt;/code>. Miner A tìm ra block &lt;code>100A&lt;/code> và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block &lt;code>100B&lt;/code> và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.&lt;/p></description></item><item><title>Phân biệt Generative AI và AI Agent cho Lập trình viên Backend</title><link>https://thanhhv.github.io/ai/generative-ai-vs-ai-agent/</link><pubDate>Sun, 27 Oct 2024 16:33:00 +0700</pubDate><guid>https://thanhhv.github.io/ai/generative-ai-vs-ai-agent/</guid><description>&lt;h2 id="generative-ai-và-ai-agent-hiểu-rõ-sự-khác-biệt-cho-backend-developers">Generative AI và AI Agent: Hiểu rõ sự khác biệt cho Backend Developers&lt;/h2>
&lt;p>Trong thế giới AI đang phát triển nhanh chóng, hai khái niệm &amp;ldquo;Generative AI&amp;rdquo; và &amp;ldquo;AI Agent&amp;rdquo; thường được nhắc đến. Bài viết này sẽ giúp các lập trình viên backend phân biệt rõ hai loại hình AI này một cách dễ hiểu.&lt;/p>
&lt;h3 id="generative-ai-là-gì">Generative AI là gì?&lt;/h3>
&lt;p>&lt;strong>Generative AI&lt;/strong> (AI tạo sinh) là một loại AI có khả năng tạo ra nội dung mới. Nội dung này có thể là văn bản, hình ảnh, âm thanh, video, hoặc thậm chí là code.&lt;/p></description></item></channel></rss>
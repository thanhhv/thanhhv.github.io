[{"content":"In Google Cloud, Compute Offering is a set of services that help you run workloads (like applications, APIs, batch jobs, etc.) on Google\u0026rsquo;s host infrastructure. Depending on your workload and requirements, you can choose from the options below:\n1. Compute Engine (IaaS - Infrastructure as a Service) A virtual machine where you have full permission to configure the environment. High level of control, similar to traditional hosting on the cloud. Use case: Configure OS in detail, install custom software, need full system control. Example: Run a Node.js/Golang server, cron job, or backend AI model training. AWS equivalent: EC2 2. App Engine (PaaS - Platform as a Service) A platform for running applications where you only need to deploy code — Google handles everything else (scaling, patching, infrastructure, etc.). Low level of control — just push your code, no need to manage servers. Use case: Rapid development, no infrastructure management needed. Example: Run a small API server, REST API, or MVP web app. AWS equivalent: Elastic Beanstalk 3. Cloud Run (Serverless Containers) Run containers (e.g., Docker) in a serverless model. Billing is based on request duration. Medium level of control — you manage the container image, while Google handles scaling and infrastructure. Use case: Leverage the benefits of containers + serverless for lightweight backends or microservices. Example: Run an API service, webhook receiver, or AI inference container. AWS equivalent: App Runner / Fargate 4. Google Kubernetes Engine (GKE) (CaaS - Container as a Service) Run containerized applications with Kubernetes. Google manages the control plane. High level of control — you can fully configure your cluster, while Google manages some parts of it. Use case: Need orchestration, CI/CD pipelines, or complex multi-service applications. Example: Run a microservices system, CI job runners, or real-time data pipelines. AWS equivalent: EKS 5. Cloud Functions (FaaS - Function as a Service) Write and deploy small functions that are triggered by events (HTTP, Pub/Sub, Cloud Storage, etc.). Extremely easy to use — just write a function, no need to manage infrastructure. Use case: Handle small event-driven logic, time-based triggers, or system integration tasks. Example: Auto-resize images, handle webhooks from Telegram/Stripe, send emails on user registration. AWS equivalent: Lambda ","permalink":"https://thanhhv.github.io/posts/google-cloud-compute-offering/","summary":"\u003cp\u003eIn Google Cloud, \u003cstrong\u003eCompute Offering\u003c/strong\u003e is a set of services that help you run workloads (like applications, APIs, batch jobs, etc.) on Google\u0026rsquo;s host infrastructure. Depending on your workload and requirements, you can choose from the options below:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"gg-cloud-comute-offering\" loading=\"lazy\" src=\"/posts/google-cloud-compute-offering/gg-compute-offering.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"1-compute-engine-iaas---infrastructure-as-a-service\"\u003e1. Compute Engine (IaaS - Infrastructure as a Service)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eA virtual machine where you have full permission to configure the environment.\u003c/li\u003e\n\u003cli\u003eHigh level of control, similar to traditional hosting on the cloud.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse case:\u003c/strong\u003e Configure OS in detail, install custom software, need full system control.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExample:\u003c/strong\u003e Run a Node.js/Golang server, cron job, or backend AI model training.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAWS equivalent:\u003c/strong\u003e EC2\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2-app-engine-paas---platform-as-a-service\"\u003e2. App Engine (PaaS - Platform as a Service)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eA platform for running applications where you only need to deploy code — Google handles everything else (scaling, patching, infrastructure, etc.).\u003c/li\u003e\n\u003cli\u003eLow level of control — just push your code, no need to manage servers.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse case:\u003c/strong\u003e Rapid development, no infrastructure management needed.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExample:\u003c/strong\u003e Run a small API server, REST API, or MVP web app.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAWS equivalent:\u003c/strong\u003e Elastic Beanstalk\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-cloud-run-serverless-containers\"\u003e3. Cloud Run (Serverless Containers)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRun containers (e.g., Docker) in a serverless model. Billing is based on request duration.\u003c/li\u003e\n\u003cli\u003eMedium level of control — you manage the container image, while Google handles scaling and infrastructure.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse case:\u003c/strong\u003e Leverage the benefits of containers + serverless for lightweight backends or microservices.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExample:\u003c/strong\u003e Run an API service, webhook receiver, or AI inference container.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAWS equivalent:\u003c/strong\u003e App Runner / Fargate\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"4-google-kubernetes-engine-gke-caas---container-as-a-service\"\u003e4. Google Kubernetes Engine (GKE) (CaaS - Container as a Service)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRun containerized applications with Kubernetes. Google manages the control plane.\u003c/li\u003e\n\u003cli\u003eHigh level of control — you can fully configure your cluster, while Google manages some parts of it.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse case:\u003c/strong\u003e Need orchestration, CI/CD pipelines, or complex multi-service applications.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExample:\u003c/strong\u003e Run a microservices system, CI job runners, or real-time data pipelines.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAWS equivalent:\u003c/strong\u003e EKS\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"5-cloud-functions-faas---function-as-a-service\"\u003e5. Cloud Functions (FaaS - Function as a Service)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eWrite and deploy small functions that are triggered by events (HTTP, Pub/Sub, Cloud Storage, etc.).\u003c/li\u003e\n\u003cli\u003eExtremely easy to use — just write a function, no need to manage infrastructure.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse case:\u003c/strong\u003e Handle small event-driven logic, time-based triggers, or system integration tasks.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExample:\u003c/strong\u003e Auto-resize images, handle webhooks from Telegram/Stripe, send emails on user registration.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAWS equivalent:\u003c/strong\u003e Lambda\u003c/li\u003e\n\u003c/ul\u003e","title":"Google Cloud Compute Offering"},{"content":"Trong thế giới công nghệ ngày nay, tiếng Anh không chỉ là một lợi thế, mà còn là một yếu tố then chốt cho sự thành công của một Backend Developer. Tại sao lại như vậy?\n1. Tiếp cận nguồn tài liệu vô tận:\nHầu hết các tài liệu, framework, thư viện, và công cụ mới nhất trong lĩnh vực backend đều được viết bằng tiếng Anh. Việc thành thạo tiếng Anh giúp bạn dễ dàng tiếp cận, học hỏi và áp dụng những kiến thức này. Thay vì phải chờ đợi bản dịch, bạn có thể tự mình khám phá và làm chủ công nghệ.\n2. Giao tiếp hiệu quả trong môi trường quốc tế:\nNgành công nghệ thông tin là một ngành toàn cầu. Bạn sẽ thường xuyên phải làm việc với đồng nghiệp, khách hàng, hoặc đối tác đến từ nhiều quốc gia khác nhau. Khả năng giao tiếp hiệu quả bằng tiếng Anh giúp bạn trao đổi thông tin rõ ràng, tránh hiểu lầm và xây dựng mối quan hệ tốt đẹp.\n3. Nắm bắt cơ hội nghề nghiệp:\nNhiều công ty công nghệ hàng đầu trên thế giới tìm kiếm những Backend Developer có khả năng tiếng Anh tốt. Việc sở hữu kỹ năng này mở ra cho bạn những cơ hội làm việc tại các dự án lớn, với mức lương hấp dẫn và cơ hội phát triển bản thân.\n4. Đóng góp cho cộng đồng:\nBackend Developer giỏi không chỉ biết sử dụng công nghệ, mà còn có khả năng đóng góp cho cộng đồng. Tiếng Anh là ngôn ngữ chung của cộng đồng lập trình viên toàn cầu. Bạn có thể chia sẻ kiến thức, kinh nghiệm, hoặc thậm chí là xây dựng các thư viện, framework open-source bằng tiếng Anh, góp phần vào sự phát triển của ngành.\nLời khuyên:\nĐầu tư thời gian và công sức: Học tiếng Anh không phải là một quá trình dễ dàng, nhưng hoàn toàn xứng đáng. Tập trung vào tiếng Anh chuyên ngành: Làm quen với các thuật ngữ, khái niệm kỹ thuật trong lĩnh vực backend. Luyện tập thường xuyên: Đọc tài liệu, xem video, tham gia các diễn đàn và cộng đồng trực tuyến bằng tiếng Anh. Tóm lại, tiếng Anh là một công cụ mạnh mẽ giúp bạn trở thành một Backend Developer chuyên nghiệp và thành công. Hãy bắt đầu trau dồi kỹ năng này ngay hôm nay!\n","permalink":"https://thanhhv.github.io/ai/importance-of-english-for-backend-developers/","summary":"\u003cp\u003eTrong thế giới công nghệ ngày nay, tiếng Anh không chỉ là một lợi thế, mà còn là một yếu tố \u003cstrong\u003ethen chốt\u003c/strong\u003e cho sự thành công của một Backend Developer. Tại sao lại như vậy?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Tiếp cận nguồn tài liệu vô tận:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eHầu hết các tài liệu, framework, thư viện, và công cụ mới nhất trong lĩnh vực backend đều được viết bằng tiếng Anh. Việc thành thạo tiếng Anh giúp bạn dễ dàng tiếp cận, học hỏi và áp dụng những kiến thức này. Thay vì phải chờ đợi bản dịch, bạn có thể tự mình khám phá và làm chủ công nghệ.\u003c/p\u003e","title":"Tầm quan trọng của tiếng Anh cho Backend Developer"},{"content":"Chào mọi người, hôm nay trong lúc mình ôn tập kiến thức thì nhớ đến Bloom Filter, thế là mình lại phải viết thêm một bài nói về cái này nữa rồi =))\nBloom Filter là một cấu trúc dữ liệu xác suất được thiết kế để kiểm tra nhanh chóng xem một phần tử có thuộc tập hợp hay không.\nCông dụng của nó là kiểm tra nhanh xem \u0026ldquo;Cái này có chưa nhỉ?\u0026rdquo;\nNếu nó bảo là chưa có → chắc chắn là chưa. Nếu nó bảo là có rồi → có thể có, hoặc là nhầm :D Ví dụ về cách hoạt động của Bloom Filter Khởi tạo một mảng bit (0,0,0,0,\u0026hellip;). Khởi tạo một vài hàm băm (h1, h2, h3,\u0026hellip;). Khi thêm một phần tử, dùng các hàm băm để tính ra các vị trí trong mảng bit → set các vị trí đó thành 1. Khi kiểm tra phần tử khác, băm ra các vị trí tương ứng và kiểm tra xem các bit đó đã là 1 chưa. Minh họa ví dụ Giả sử bài toán là: Nhận một đoạn text, nếu đoạn text đã tồn tại thì báo lỗi, nếu chưa thì thêm vào.\n1. Khởi tạo mảng bit Giả sử 8 bit: [0,0,0,0,0,0,0,0] (Chọn 8 cho dễ minh họa, thực tế có thể hàng ngàn bit. Nếu quá nhỏ → dễ xung đột bit, tăng false positive. Nếu quá lớn → tốn bộ nhớ.)\n2. Định nghĩa hàm băm: h1(x) = (sum of ASCII letters) % 8 h2(x) = (length of string * 3) % 8 3. Thêm phần tử cat h1(\u0026ldquo;cat\u0026rdquo;) = (99 + 97 + 116) % 8 = 312 % 8 = 0 → bit[0] = 1 h2(\u0026ldquo;cat\u0026rdquo;) = 3 * 3 = 9 → 9 % 8 = 1 → bit[1] = 1 Mảng bit: [1,1,0,0,0,0,0,0]\n4. Kiểm tra phần tử dog h1(\u0026ldquo;dog\u0026rdquo;) = (100 + 111 + 103) = 314 → 314 % 8 = 2 h2(\u0026ldquo;dog\u0026rdquo;) = 3 * 3 = 9 → 9 % 8 = 1 Kiểm tra bit[2] = 0 → chắc chắn dog chưa có → set bit[2] = 1\nMảng bit: [1,1,1,0,0,0,0,0]\n5. Thêm phần tử duck h1(\u0026ldquo;duck\u0026rdquo;) = (100 + 117 + 99 + 107) = 423 % 8 = 7 h2(\u0026ldquo;duck\u0026rdquo;) = 4 * 3 = 12 → 12 % 8 = 4 Update: bit[7] = 1, bit[4] = 1\nMảng bit: [1,1,1,0,1,0,0,1]\n6. Kiểm tra lại cat h1(\u0026ldquo;cat\u0026rdquo;) = 0, h2(\u0026ldquo;cat\u0026rdquo;) = 1 → bit[0] và bit[1] đều = 1 → có thể tồn tại → cần kiểm tra lại DB để chắc chắn. 7. Ví dụ dương tính giả với god h1(\u0026ldquo;god\u0026rdquo;) = (103 + 111 + 100) = 314 % 8 = 2 h2(\u0026ldquo;god\u0026rdquo;) = 3 * 3 = 9 % 8 = 1 bit[2] = 1, bit[1] = 1 → Bloom Filter nói: \u0026ldquo;god có thể tồn tại\u0026rdquo;. Nhưng thực tế chưa từng thêm god. → Đây là false positive: các phần tử trước đó đã vô tình bật bit đó.\nCác trường hợp sử dụng phổ biến trong backend ✅ Kiểm tra nhanh username đã tồn tại chưa Người dùng nhập username = gavin\nHash gavin bằng h1, h2 → bật các bit tương ứng → lưu mảng bit vào Redis\nLần sau có người nhập gavin, hash lại:\nNếu ít nhất 1 bit = 0 → chắc chắn chưa tồn tại → cho phép tạo tài khoản Nếu tất cả bit = 1 → có thể đã tồn tại → cần truy vấn DB để xác thực ➡️ Giảm tải cho DB, phản hồi nhanh\n⚠️ Bloom Filter không thay thế DB, vì có thể false positive\n✅ Kiểm tra blacklist, spam IP/email Dùng Bloom Filter để lưu các IP/email bị chặn Trước khi xử lý request, check nhanh qua Bloom Filter ➡️ Rất nhanh và nhẹ, tiết kiệm truy vấn\nHy vọng bài viết giúp bạn hiểu rõ hơn về Bloom Filter và ứng dụng nó vào các hệ thống thực tế một cách hiệu quả!\n","permalink":"https://thanhhv.github.io/posts/bloom-filter/","summary":"\u003cp\u003eChào mọi người, hôm nay trong lúc mình ôn tập kiến thức thì nhớ đến Bloom Filter, thế là mình lại phải viết thêm một bài nói về cái này nữa rồi =))\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBloom Filter\u003c/strong\u003e là một cấu trúc dữ liệu xác suất được thiết kế để kiểm tra nhanh chóng xem một phần tử có thuộc tập hợp hay không.\u003c/p\u003e\n\u003cp\u003eCông dụng của nó là kiểm tra nhanh xem \u003cem\u003e\u0026ldquo;Cái này có chưa nhỉ?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"Bloom filter là gì và trường hợp sử dụng"},{"content":"Tại sao thuật toán là yếu tố sống còn cho Backend Senior? Khi bạn mới bắt đầu sự nghiệp lập trình, việc nắm vững cú pháp và các framework là điều cần thiết. Nhưng khi bạn tiến lên vị trí Senior Backend Developer, yêu cầu không chỉ dừng lại ở việc \u0026ldquo;làm được\u0026rdquo; mà còn là \u0026ldquo;làm tốt nhất\u0026rdquo;. Và ở đó, thuật toán đóng vai trò then chốt.\n1. Hiệu năng là ưu tiên hàng đầu:\nBackend là trái tim của ứng dụng, chịu trách nhiệm xử lý dữ liệu và logic nghiệp vụ. Một backend chậm chạp sẽ ảnh hưởng trực tiếp đến trải nghiệm người dùng.\nTối ưu hóa tốc độ xử lý: Thuật toán hiệu quả giúp giảm thiểu thời gian xử lý yêu cầu. Ví dụ, việc chọn thuật toán tìm kiếm phù hợp (binary search thay vì linear search) có thể tạo ra sự khác biệt lớn khi làm việc với dữ liệu lớn. Quản lý tài nguyên: Thuật toán tốt giúp sử dụng tài nguyên (CPU, memory) một cách hiệu quả hơn. Một thuật toán không tối ưu có thể gây lãng phí tài nguyên, dẫn đến scaling khó khăn và tốn kém. Xử lý đồng thời: Trong môi trường backend, việc xử lý đồng thời nhiều yêu cầu là rất quan trọng. Hiểu biết về các thuật toán concurrency và locking là bắt buộc để tránh deadlock, race condition và đảm bảo tính toàn vẹn dữ liệu. 2. Giải quyết các vấn đề phức tạp:\nCông việc của một Senior Backend Developer thường liên quan đến việc giải quyết các vấn đề phức tạp về kiến trúc, hiệu năng và khả năng mở rộng.\nThiết kế hệ thống: Hiểu biết về các thuật toán và cấu trúc dữ liệu giúp bạn đưa ra các quyết định thiết kế tốt hơn. Ví dụ, việc chọn cấu trúc dữ liệu phù hợp (graph database thay vì relational database) có thể là chìa khóa để giải quyết các vấn đề liên quan đến quan hệ phức tạp giữa các đối tượng. Xây dựng các API hiệu quả: Thuật toán đóng vai trò quan trọng trong việc xây dựng các API có hiệu năng cao. Ví dụ, việc sử dụng caching (LRU, FIFO) có thể giúp giảm tải cho database và cải thiện thời gian phản hồi của API. Phân tích và xử lý dữ liệu lớn: Với sự gia tăng của dữ liệu, khả năng phân tích và xử lý dữ liệu lớn trở nên quan trọng hơn bao giờ hết. Hiểu biết về các thuật toán machine learning và data mining là một lợi thế lớn. 3. Khả năng học hỏi và thích ứng:\nThế giới công nghệ luôn thay đổi. Các framework và thư viện mới liên tục ra đời. Tuy nhiên, những kiến thức cơ bản về thuật toán và cấu trúc dữ liệu vẫn luôn đúng.\nNền tảng vững chắc: Thuật toán cung cấp một nền tảng vững chắc để bạn có thể học hỏi và thích ứng với các công nghệ mới một cách nhanh chóng. Khả năng giải quyết vấn đề: Khi bạn gặp một vấn đề mới, khả năng phân tích và áp dụng các kiến thức về thuật toán sẽ giúp bạn tìm ra giải pháp hiệu quả. Tóm lại:\nĐối với một Senior Backend Developer, thuật toán không chỉ là một môn học khô khan mà là một công cụ mạnh mẽ giúp bạn xây dựng các hệ thống hiệu quả, giải quyết các vấn đề phức tạp và luôn sẵn sàng đối mặt với những thách thức mới. Đầu tư vào việc học và rèn luyện kỹ năng thuật toán là một khoản đầu tư xứng đáng cho sự nghiệp của bạn\n","permalink":"https://thanhhv.github.io/ai/thuat-toan-backend-senior/","summary":"\u003ch2 id=\"tại-sao-thuật-toán-là-yếu-tố-sống-còn-cho-backend-senior\"\u003eTại sao thuật toán là yếu tố sống còn cho Backend Senior?\u003c/h2\u003e\n\u003cp\u003eKhi bạn mới bắt đầu sự nghiệp lập trình, việc nắm vững cú pháp và các framework là điều cần thiết. Nhưng khi bạn tiến lên vị trí Senior Backend Developer, yêu cầu không chỉ dừng lại ở việc \u0026ldquo;làm được\u0026rdquo; mà còn là \u0026ldquo;làm tốt nhất\u0026rdquo;.  Và ở đó, thuật toán đóng vai trò then chốt.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Hiệu năng là ưu tiên hàng đầu:\u003c/strong\u003e\u003c/p\u003e","title":"Tại sao thuật toán là yếu tố sống còn cho Backend Senior?"},{"content":"Hợp đồng thông minh DEX Trong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: Factory, Router, và Pair. Vai trò của từng hợp đồng như sau:\n🔹 1. Factory Contract Là nơi đăng ký chính của các pool thanh khoản (cặp token). Tạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới. Lưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng. Các hàm chính:\ncreatePair(tokenA, tokenB): Triển khai hợp đồng Pair mới cho cặp tokenA và tokenB. getPair(tokenA, tokenB): Trả về địa chỉ hợp đồng Pair. allPairs(): Trả về danh sách tất cả các cặp đã tạo. Ví dụ:\nNếu người dùng muốn giao dịch Token A ↔ Token B mà chưa có pool, Factory sẽ tạo hợp đồng Pair mới.\n🔹 2. Router Contract Là hợp đồng chính mà người dùng tương tác để hoán đổi token, thêm/bớt thanh khoản và định tuyến giao dịch. Gọi đến Factory để tìm hợp đồng Pair tương ứng. Đảm bảo giá tốt nhất bằng cách định tuyến giao dịch qua nhiều cặp token. Các hàm chính:\nswapExactTokensForTokens(amountIn, minAmountOut, path, recipient, deadline): Hoán đổi amountIn của Token A sang Token B. addLiquidity(tokenA, tokenB, amountA, amountB, minA, minB, to, deadline): Thêm thanh khoản vào một Pair. removeLiquidity(tokenA, tokenB, liquidity, minA, minB, to, deadline): Rút thanh khoản khỏi Pair. Ví dụ:\nNgười dùng muốn đổi Token A sang Token B:\nRouter kiểm tra tuyến giao dịch tối ưu (trực tiếp hoặc qua nhiều cặp). Gọi đến hợp đồng Pair để thực hiện giao dịch. Token được chuyển giao tương ứng. 🔹 3. Pair Contract (Liquidity Pool) Quản lý pool thanh khoản cho một cặp token. Sử dụng công thức AMM sản phẩm không đổi:\nx * y = k\nTrong đó x và y là lượng token dự trữ, k là hằng số không đổi. Các hàm chính:\nswap(amount0Out, amount1Out, to): Thực hiện hoán đổi token. mint(to): Mint token LP (liquidity provider). burn(to): Burn token LP và trả lại token gốc. getReserves(): Trả về lượng token dự trữ. Ví dụ:\nNếu có giao dịch Token A → Token B:\nNgười dùng gửi Token A vào hợp đồng Pair. Pair tính toán số Token B trả lại dựa vào công thức AMM. Gửi Token B cho người dùng, cập nhật dự trữ. 🛠 Các hợp đồng khác trong DEX 🔹 4. Multicall Contract (tùy chọn) Cho phép thực hiện nhiều lệnh gọi hợp đồng trong một giao dịch (ví dụ: kiểm tra nhiều giá cùng lúc). 🔹 5. Fee Collection Contract (tùy chọn) Nếu DEX thu phí giao thức, sẽ có hợp đồng riêng để thu và phân phối phí. 🎯 Cách các hợp đồng phối hợp với nhau Tạo cặp token mới:\nFactory triển khai hợp đồng Pair nếu chưa tồn tại. Thêm thanh khoản:\nNgười dùng gọi Router, Router nạp token vào Pair contract. Người dùng nhận lại token LP. Hoán đổi token:\nNgười dùng gọi Router để hoán đổi. Router tìm đúng Pair và thực hiện swap. Rút thanh khoản:\nNgười dùng trả lại token LP cho Router, Router rút tài sản từ Pair. 🚀 Ví dụ luồng swap Giả sử bạn muốn hoán đổi 100 USDT → ETH trên DEX:\nNgười dùng gọi:\nswapExactTokensForTokens(100 USDT, minETH, [USDT, ETH], recipient, deadline) Router truy xuất hợp đồng Pair (USDT/ETH) từ Factory. Pair tính toán số ETH trả lại theo công thức AMM. Gửi ETH cho người dùng, USDT thêm vào dự trữ. 🔥 Tổng kết Hợp đồng Mục đích Factory Tạo và theo dõi các hợp đồng Pair (pool thanh khoản). Router Xử lý swap, định tuyến, quản lý thanh khoản. Pair Giữ token dự trữ, thực hiện swap theo AMM. Multicall (tuỳ chọn) Gộp nhiều lệnh gọi hợp đồng thành một giao dịch. Fee Collection (tuỳ chọn) Thu và phân phối phí giao thức. Uniswap V2 - Công thức sản phẩm không đổi và cách tính giá Uniswap V2 hoạt động theo mô hình AMM (Automated Market Maker), nơi tính thanh khoản trong pool được duy trì bởi công thức sản phẩm không đổi:\nx * y = k\nTrong đó:\nx = Số lượng Token X trong pool y = Số lượng Token Y trong pool k = Hằng số không đổi sau mỗi giao dịch Ví dụ:\nToken X là ETH Token Y là USDT Thiết lập ban đầu Pool có:\n1000 ETH 500,000 USDT k = 1000 * 500,000 = 500,000,000\nBước 1: Tính giá ban đầu Giá ETH theo USDT:\n1 ETH = 500 USDT\nBước 2: Giao dịch swap Người dùng swap 100 ETH → USDT\nETH trong pool: 1000 → 1100\nUSDT giảm để giữ k = 500,000,000\nBước 3: Tính USDT mới 1100 * y' = 500,000,000 → y' = 454,545.45 USDT\nBước 4: Tính số USDT nhận được 500,000 - 454,545.45 = 45,454.55 USDT\nBước 5: Giá ETH mới 1 ETH ≈ 412.37 USDT\nTóm tắt Trạng thái ETH USDT Giá ETH Trước swap 1000 500,000 500 USDT Sau swap 1100 454,545.45 412.37 USDT Kết luận Tác động giá: Giá ETH giảm vì tỉ lệ thay đổi. Sản phẩm không đổi: k không đổi, đảm bảo thanh khoản. Lợi ích LP: Kiếm phí nhưng có nguy cơ tổn thất tạm thời. Bài viết được mình dịch từ duyquoc1508, cám ơn Quốc vì đã có 1 bài viết quá chi tiết này.\n","permalink":"https://thanhhv.github.io/posts/dex/","summary":"\u003ch2 id=\"hợp-đồng-thông-minh-dex\"\u003eHợp đồng thông minh DEX\u003c/h2\u003e\n\u003cp\u003eTrong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: \u003cstrong\u003eFactory\u003c/strong\u003e, \u003cstrong\u003eRouter\u003c/strong\u003e, và \u003cstrong\u003ePair\u003c/strong\u003e. Vai trò của từng hợp đồng như sau:\u003c/p\u003e\n\u003ch3 id=\"-1-factory-contract\"\u003e🔹 1. Factory Contract\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLà nơi đăng ký chính của các pool thanh khoản (cặp token).\u003c/li\u003e\n\u003cli\u003eTạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới.\u003c/li\u003e\n\u003cli\u003eLưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCác hàm chính:\u003c/strong\u003e\u003c/p\u003e","title":"Tổng quan về Hợp đồng Thông minh trong DEX và AMM"},{"content":"Bạn đang tìm kiếm một web server open source mới, mạnh mẽ và dễ sử dụng? Hãy cùng khám phá Candyserver!\nCandyserver là một web server mới nổi, được xây dựng với mục tiêu cung cấp hiệu suất cao, tính linh hoạt và trải nghiệm người dùng thân thiện. Mặc dù còn khá mới, Candyserver đã thu hút sự chú ý của cộng đồng open source nhờ những ưu điểm sau:\nHiệu suất: Candyserver được tối ưu hóa để xử lý lượng lớn request một cách hiệu quả, giúp website của bạn hoạt động mượt mà ngay cả khi có nhiều người truy cập. Dễ cấu hình: Giao diện cấu hình đơn giản và trực quan giúp bạn dễ dàng cài đặt và tùy chỉnh Candyserver theo nhu cầu của mình. Tính năng: Candyserver hỗ trợ nhiều tính năng quan trọng như HTTPS, HTTP/2, reverse proxy, load balancing, và nhiều hơn nữa. Open Source: Được phát triển dưới giấy phép open source, Candyserver mang lại sự minh bạch và khả năng tùy chỉnh cao cho người dùng. Cộng đồng: Mặc dù còn non trẻ, Candyserver đã có một cộng đồng người dùng và nhà phát triển đang phát triển nhanh chóng, sẵn sàng hỗ trợ và chia sẻ kinh nghiệm. Nếu bạn đang tìm kiếm một web server open source thay thế cho các lựa chọn truyền thống, Candyserver là một ứng cử viên đáng để thử. Hãy truy cập trang web chính thức của Candyserver để tìm hiểu thêm về cách cài đặt, cấu hình và sử dụng.\nBạn nghĩ gì về Candyserver? Hãy chia sẻ ý kiến của bạn trong phần bình luận bên dưới!\n","permalink":"https://thanhhv.github.io/ai/candyserver-web-server-open-source/","summary":"\u003cp\u003eBạn đang tìm kiếm một web server open source mới, mạnh mẽ và dễ sử dụng? Hãy cùng khám phá Candyserver!\u003c/p\u003e\n\u003cp\u003eCandyserver là một web server mới nổi, được xây dựng với mục tiêu cung cấp hiệu suất cao, tính linh hoạt và trải nghiệm người dùng thân thiện. Mặc dù còn khá mới, Candyserver đã thu hút sự chú ý của cộng đồng open source nhờ những ưu điểm sau:\u003c/p\u003e","title":"Giới thiệu Candyserver: Web Server Open Source Mới Đầy Hứa Hẹn"},{"content":"Xin chào mọi người,\nTrong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có Node.js và Golang. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let\u0026rsquo;s start!\n1. Hiệu năng và Đa luồng Golang có hiệu năng tốt hơn nhờ là compiled language và mô hình goroutine rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.\nNode.js dùng event loop, rất hiệu quả cho ứng dụng I/O-bound, nhưng dễ bị nghẽn khi xử lý CPU-bound do chạy đơn luồng (có thể dùng worker threads nhưng không phải là mặc định).\nVậy nên, nếu hệ thống cần xử lý song song, real-time, high concurrency → Golang là lựa chọn tốt.\nMình sẽ chú thích thêm 1 xíu về I/O-bound và CPU-bound là gì cho mọi người dễ follow nhé:\nI/O-bound: là tác vụ mà CPU phải chờ dữ liệu từ ngoài: đọc file, query DB, gởi request network\u0026hellip;\nawait fetch(\u0026#39;https://api.example.com/data\u0026#39;) CPU-bound: là tác vụ sử dụng nhiều CPU, như tính toán, mã hoá, AI\u0026hellip;\nfor (let i = 0; i \u0026lt; 1e9; i++) { // Tính toán số nguyên tố } 2. Tốc độ phát triển \u0026amp; Hệ sinh thái Node.js: ecosystem mạnh, npm phong phú, build nhanh, nhất là khi làm với frontend (JS/TS). Golang: code rõ ràng, nhưng viết nhiều hơn vì ít thư viện có sẵn. Nên nếu cần tốc độ phát triển nhanh → Nodejs là lựa chọn tốt.\n3. Maintainability \u0026amp; Readability Golang: strict typing, clear structure → dễ maintain trong team. Node.js: Typescript thì ổn, JavaScript thuần thì dễ sinh bug. Nên dự án quy mô lớn → Golang tốt hơn về dài hạn.\n4. Use Case thực tế Dự án DEX:\nGolang cho core server xử lý thuật toán tìm đường đi tối ưu nhất giữa các pool để swap token (CPU-bound). Node.js cho crawler/router (I/O-bound). Dự án web/blog:\nNode.js phù hợp do chủ yếu fetch dữ liệu DB trả về. 5. Khả năng xử lý I/O Thực ra Golang cũng xử lý I/O bất đồng bộ rất tốn nhờ goroutines và non-blocking calls. Nhưng có lý do tại sao người ta vẫn nói Nodejs mạnh hơn về I/O, đặc biệt là trong các hệ thống I/O intensive (API gateway, proxy server)\nYếu tố Node.js Golang I/O Handling Event loop + libuv + Non-blocking I/O Goroutine + epoll/kqueue (runtime quản lý) Concurrency Model Single-threaded với event loop Multi-threaded với goroutines Resource Usage Ít RAM (1 thread chính + thread pool khi cần) Nhẹ (goroutines ~2KB stack size) I/O Performance Cực nhanh cho I/O nhỏ Tốt nhưng có overhead khi nhiều goroutines Throughput Rất cao với lượng request nhỏ, nhanh Ổn định với request lớn, dài hạn Nodejs có event-loop hoạt động mạnh như disptacher trung tâm: Request nhỏ (đọc file, query db, network) được đưa và libuv. Không cần tạo thread mới -\u0026gt; do là single thread , chỉ cần 1 thread chính để quản lý mọi thứ. callback-based -\u0026gt; event loop chỉ cần biết là khi nào I/O xong để tiếp tục xử lý. Kết quả: với lượng I/O nhỏ và nhanh, nodejs cực kì nhanh và không bị lãng phí tài nguyên so với việc tạo goroutines/thread không cần thiết. Go thì khác: mỗi request sẽ tạo 1 goroutine (nhẹ, những vẫn là context riêng) Runtime của go quản lý goroutines bằng M:N Scheduler (map nhiều goroutines vào ít thread) Nếu request nhiều quá, runtime phải liên tục schedule và switch context -\u0026gt; có overhead dù nhỏ. Kết quả: với lượng I/O nhỏ, liên tục, việc context swiching quá nhiều có thể làm giảm hiệu suất so với nodejs. Khi nào Node.js vượt trội? API gateway (hàng triệu request/ngày) Chat app, notification Proxy server Streaming app (WebSocket, video chunks) ✅ I/O-heavy → Node.js\n✅ CPU-heavy → Golang\nNói chung cả Nodejs và Golang đều rất mạnh mẽ, nhưng chúng phù hợp với từng usecase khác nhau. Chúng ta nên quan trọng việc chọn đúng công cụ cho bài toán hơn là chỉ chọn theo sở thích cá nhân.\nCảm ơn bạn đã đọc đến đây. Hẹn gặp lại trong bài viết tiếp theo nhé! 🙌\n","permalink":"https://thanhhv.github.io/posts/nodejs-vs-go/","summary":"\u003cp\u003eXin chào mọi người,\u003c/p\u003e\n\u003cp\u003eTrong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có \u003cstrong\u003eNode.js\u003c/strong\u003e và \u003cstrong\u003eGolang\u003c/strong\u003e. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let\u0026rsquo;s start!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Nodejs-vs-Golang\" loading=\"lazy\" src=\"/posts/nodejs-vs-go/nodejs-go.png\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-hiệu-năng-và-đa-luồng\"\u003e1. Hiệu năng và Đa luồng\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eGolang\u003c/strong\u003e có hiệu năng tốt hơn nhờ là compiled language và mô hình \u003cstrong\u003egoroutine\u003c/strong\u003e rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.\u003c/p\u003e","title":"So sánh Node.js và Golang trong Backend"},{"content":"Hôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,\u0026hellip;). Cùng bắt đầu nhé! Quá trình này gồm 3 bước đơn giản:\n1. Lấy message từ server Đầu tiên, client sẽ gửi request đến server để lấy message về. Đây là nội dung mà client sẽ ký bằng ví như Metamask để xác thực với dApp.\nVì message cần được thống nhất giữa server và client, nên server nên là bên tạo và quản lý message này.\nVí dụ message: thanhhv.github.io wants you to sign in with your Ethereum account: 0xA1B2...D3E4 Sign-in request for MyDApp URI: https://thanhhv.github.io Version: 1 Chain ID: 1 Nonce: 839174 Issued At: 2025-05-11T20:40:00Z Đây là định dạng theo EIP-4361 (Sign-In With Ethereum) được sử dụng phổ biến.\nNonce là số ngẫu nhiên dùng một lần (có thể dùng UUID), kết hợp với timestamp để tránh replay attack.\nServer nên tạo nonce, lưu vào database với các field:\nnonce, wallet, expiresAt, used = false, sau đó gắn vào message trả về cho client.\n2. Client ký message bằng private key Sau khi nhận được message, client sẽ dùng private key để ký.\nVí dụ sử dụng thư viện ethers:\nconst { ethers } = require(\u0026#34;ethers\u0026#34;); const wallet = new ethers.Wallet(process.env.PRIVATE_KEY); const signature = await wallet.signMessage(message); Client sau đó gửi { message, signature } về server.\n3. Server xác thực chữ ký Server sẽ:\nTách nonce từ message ra. Truy vấn DB để kiểm tra: Có tồn tại không? Hết hạn chưa? Đã được sử dụng chưa? Sau đó, dùng ethers để xác thực chữ ký:\nconst { ethers } = require(\u0026#34;ethers\u0026#34;); const recoveredAddress = ethers.utils.verifyMessage(message, signature); const isValid = recoveredAddress.toLowerCase() === addressFromRequest; Nếu hợp lệ, server có thể cập nhật DB: used = true, và cho phép đăng nhập thành công.\n4. Bonus: Kết hợp với JWT Giả sử bạn đang xây dựng trang quản trị admin, sau khi bước 3 hoàn tất, server có thể tạo 1 JWT token. Những request tiếp theo sẽ dùng token này để xác thực — giống như mô hình web2 quen thuộc.\nTuy là đăng nhập bằng ví crypto, nhưng sau đó bạn có thể tương tác với hệ thống như người dùng thông thường, vừa an toàn, vừa tiện lợi.\nHết rồi! Hy vọng bài viết hữu ích cho bạn nào đang tìm hiểu về Web3 authentication. Chúc cho tôi sẽ may mắn vượt qua vòng phỏng vấn sắp tới nhé, hihi 😄\n","permalink":"https://thanhhv.github.io/posts/verify-user-wallet/","summary":"\u003cp\u003eHôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,\u0026hellip;). Cùng bắt đầu nhé! Quá trình này gồm \u003cstrong\u003e3 bước đơn giản\u003c/strong\u003e:\u003c/p\u003e","title":"Xác thực người dùng bằng ví crypto"},{"content":"1. Cơ bản về cách blockchain thêm block Các blockchain như Ethereum, Bitcoin hoạt động như sau:\nMỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại. Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng. Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình. Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.\nGiả sử mạng lưới đang dừng ở block thứ 99. Miner A tìm ra block 100A và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block 100B và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.\nLúc này, blockchain tạo ra hai nhánh tạm thời (gọi là temporary fork) ở block thứ 100.\n2. Khi nào xảy ra re-org? Giả sử Miner C đào tiếp block 101 dựa trên 100B, chuỗi lúc này là:\nBlock 99 -\u0026gt; Block 100B -\u0026gt; Block 101 Trong khi đó, bạn đang theo chuỗi:\nBlock 99 -\u0026gt; Block 100A Theo quy tắc longest chain, blockchain sẽ chọn chuỗi dài hơn là chuỗi chính thức.\nVì vậy, chain 100B -\u0026gt; 101 sẽ được chấp nhận, và block 100A bị loại bỏ.\nQuá trình này gọi là chain reorganization (re-org).\nRe-org là lúc mà mạng đổi ý và chọn một nhánh mới dài hơn, bỏ qua nhánh cũ — giống như chơi cờ mà bỗng dưng đi lại nước trước đó vì thấy đường khác ngon hơn!\n3. Các kỹ thuật xử lý khi re-org xảy ra ở phía backend 3.1. Delay block confirmation Đây là cách phổ biến và đơn giản nhất.\nKhi indexing dữ liệu từ blockchain, bạn bỏ qua một vài block cuối cùng để tránh sai sót do re-org.\nVí dụ:\nTrên Ethereum, thường bỏ qua 12 block cuối (tức chỉ xử lý đến latest - 12). Các chain khác sẽ có con số riêng, bạn cần tra thêm tài liệu. Tuy nhiên, cách này có độ trễ nên có thể kèm theo giải pháp UI như:\n\u0026ldquo;Đang xử lý dữ liệu\u0026hellip; lần cập nhật gần nhất 1 phút trước\u0026rdquo;\n3.2. Xây dựng hệ thống rollback tự động (phức tạp hơn) Để dữ liệu gần như realtime nhưng vẫn chính xác, bạn có thể xây hệ thống hỗ trợ rollback khi re-org:\nKhi lưu dữ liệu từ block, luôn lưu kèm blockNumber và blockHash. Mỗi khi có block mới, kiểm tra lại N block trước đó (ví dụ: 12 block). Nếu blockHash không khớp với dữ liệu đã lưu: Rollback: xóa dữ liệu liên quan block cũ, sync lại block mới. Hoặc tạo record mới với trạng thái như: confirmed, reorged, replaced,\u0026hellip; để phục vụ audit. Phương pháp này chính xác hơn, nhưng phức tạp và tốn công hơn rất nhiều.\nViệc lựa chọn cách xử lý phù hợp nên linh hoạt tùy vào yêu cầu hệ thống và đặc thù sản phẩm bạn đang làm.\n👋 Kết Hy vọng bài viết giúp bạn hiểu rõ hơn về khái niệm re-org và cách đối phó với nó trong backend.\nCảm ơn mọi người đã đọc tới đây. Hẹn gặp lại ở bài viết tiếp theo nhé! 🚀\n","permalink":"https://thanhhv.github.io/posts/reorg-in-blockchain/","summary":"\u003ch2 id=\"1-cơ-bản-về-cách-blockchain-thêm-block\"\u003e1. Cơ bản về cách blockchain thêm block\u003c/h2\u003e\n\u003cp\u003eCác blockchain như Ethereum, Bitcoin hoạt động như sau:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại.\u003c/li\u003e\n\u003cli\u003eKhi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng.\u003c/li\u003e\n\u003cli\u003eCác node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.\u003cbr\u003e\nGiả sử mạng lưới đang dừng ở block thứ \u003ccode\u003e99\u003c/code\u003e. Miner A tìm ra block \u003ccode\u003e100A\u003c/code\u003e và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block \u003ccode\u003e100B\u003c/code\u003e và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.\u003c/p\u003e","title":"Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain \"đổi ý\""},{"content":"Xin chào các bạn,\nTrong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là SQL và NoSQL, cụ thể là PostgreSQL và MongoDB. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.\nTôi có thể khẳng định ngay từ đầu rằng không có loại cơ sở dữ liệu nào là \u0026ldquo;tốt nhất\u0026rdquo;, mà chỉ có loại phù hợp nhất với bối cảnh và yêu cầu của dự án tại thời điểm đó.\n1. Tính linh hoạt và yêu cầu thay đổi Nếu dự án có deadline gấp, trong khi yêu cầu nghiệp vụ hoặc schema dữ liệu còn mơ hồ và dễ thay đổi liên tục, tôi sẽ ưu tiên sử dụng NoSQL, cụ thể là MongoDB.\nLý do là vì MongoDB không yêu cầu schema cố định, cho phép thay đổi cấu trúc dữ liệu linh hoạt mà không cần thực hiện các bước migration phức tạp như với cơ sở dữ liệu quan hệ. Điều này giúp tiết kiệm đáng kể thời gian và công sức trong giai đoạn phát triển ban đầu.\n2. Tính ổn định, toàn vẹn dữ liệu và nghiệp vụ phức tạp Ngược lại, nếu dự án đòi hỏi tính toàn vẹn dữ liệu cao, chẳng hạn như các hệ thống tài chính, ngân hàng hoặc thương mại điện tử, thì tôi sẽ ưu tiên sử dụng SQL, như PostgreSQL.\nPostgreSQL hỗ trợ ACID tốt, xử lý tốt các mối quan hệ phức tạp, kể cả khi sử dụng dữ liệu JSON, mà vẫn đảm bảo hiệu năng. Cấu trúc dữ liệu rõ ràng, chặt chẽ giúp dễ dàng phát hiện và ngăn chặn lỗi logic từ sớm.\nNgược lại, MongoDB lại quá linh hoạt, điều này tiềm ẩn nhiều rủi ro nếu dev không kiểm soát tốt. Tôi từng gặp trường hợp trong một dự án mà nhiều team cùng sử dụng chung một MongoDB instance. Mỗi team lại định nghĩa collection Users theo cách riêng, với các field khác nhau — dẫn đến việc khó bảo trì, khó hiểu dữ liệu, và dễ phát sinh lỗi khó debug.\n3. Nguồn lực và năng lực của team Bên cạnh yêu cầu kỹ thuật, chúng ta cũng cần xem xét năng lực của team backend và team DevOps trong việc triển khai và vận hành hệ thống.\nNếu team đã quen sử dụng PostgreSQL hoặc có kinh nghiệm xử lý dữ liệu phức tạp, thì PostgreSQL sẽ là lựa chọn hiệu quả hơn. Nếu team mạnh về Node.js, JavaScript, và đã quen dùng Mongoose, thì có thể cân nhắc sử dụng MongoDB nếu phù hợp với yêu cầu dự án. Trong trường hợp nguồn lực hạn chế, chưa thể đầu tư cho một loại database mới, thì có thể tạm thời sử dụng giải pháp hiện tại, nhưng cần có kế hoạch cho việc chuyển đổi sau này, ví dụ như áp dụng Repository Pattern để tách biệt phần logic truy cập cơ sở dữ liệu khỏi business logic. 4. Tổng kết Tôi thường không chọn database theo cảm tính hay thói quen, mà sẽ đánh giá dựa trên các tiêu chí:\nYêu cầu nghiệp vụ Tính chất dữ liệu Deadline triển khai Năng lực đội ngũ kỹ thuật Tôi không tin vào “công nghệ tốt nhất”, mà tin vào “công nghệ phù hợp nhất với bài toán cụ thể tại thời điểm cụ thể”.\n","permalink":"https://thanhhv.github.io/posts/mongodb-vs-postgresql/","summary":"\u003cp\u003eXin chào các bạn,\u003c/p\u003e\n\u003cp\u003eTrong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là \u003cstrong\u003eSQL\u003c/strong\u003e và \u003cstrong\u003eNoSQL\u003c/strong\u003e, cụ thể là \u003cstrong\u003ePostgreSQL\u003c/strong\u003e và \u003cstrong\u003eMongoDB\u003c/strong\u003e. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.\u003c/p\u003e","title":"SQL vs NoSQL"},{"content":"🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at thanhhv.github.io. Stay tuned for more!\n","permalink":"https://thanhhv.github.io/posts/welcome/","summary":"\u003cp\u003e🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at \u003cstrong\u003ethanhhv.github.io\u003c/strong\u003e. Stay tuned for more!\u003c/p\u003e","title":"Welcome"},{"content":"Generative AI và AI Agent: Hiểu rõ sự khác biệt cho Backend Developers Trong thế giới AI đang phát triển nhanh chóng, hai khái niệm \u0026ldquo;Generative AI\u0026rdquo; và \u0026ldquo;AI Agent\u0026rdquo; thường được nhắc đến. Bài viết này sẽ giúp các lập trình viên backend phân biệt rõ hai loại hình AI này một cách dễ hiểu.\nGenerative AI là gì? Generative AI (AI tạo sinh) là một loại AI có khả năng tạo ra nội dung mới. Nội dung này có thể là văn bản, hình ảnh, âm thanh, video, hoặc thậm chí là code.\nĐiểm mấu chốt: Generative AI tập trung vào việc tạo ra một cái gì đó mới dựa trên dữ liệu nó đã được huấn luyện.\nVí dụ:\nChatGPT: Tạo văn bản, dịch ngôn ngữ, trả lời câu hỏi. DALL-E 2, Stable Diffusion: Tạo hình ảnh từ mô tả bằng văn bản. GitHub Copilot: Đề xuất code trong quá trình lập trình. Backend Developers cần biết:\nGenerative AI có thể giúp tự động hóa các tác vụ như viết tài liệu API, tạo mock data, hoặc thậm chí là tạo code boilerplate. Các mô hình Generative AI thường rất tốn kém để huấn luyện và triển khai. Backend developers có thể tích hợp các API của các mô hình Generative AI vào các ứng dụng của mình. AI Agent là gì? AI Agent (tác nhân AI) là một loại AI có khả năng tự hành để đạt được một mục tiêu cụ thể trong một môi trường nhất định.\nĐiểm mấu chốt: AI Agent tập trung vào việc ra quyết định và thực hiện hành động để đạt được mục tiêu.\nVí dụ:\nHệ thống điều khiển tự động: Điều khiển nhiệt độ trong một tòa nhà để tiết kiệm năng lượng. Robot hút bụi: Tự động dọn dẹp nhà cửa. Hệ thống gợi ý sản phẩm: Đề xuất sản phẩm cho người dùng dựa trên lịch sử mua hàng của họ. Backend Developers cần biết:\nAI Agent thường bao gồm các thành phần như: Perception: Cảm nhận môi trường xung quanh. Reasoning: Suy luận và đưa ra quyết định. Action: Thực hiện hành động. Backend developers có thể xây dựng các AI Agent để tự động hóa các tác vụ như giám sát hệ thống, phát hiện lỗi, hoặc thậm chí là phản hồi các sự cố. AI Agent cần được thiết kế để hoạt động một cách an toàn và đáng tin cậy. So sánh Generative AI và AI Agent Đặc điểm Generative AI AI Agent Mục tiêu Tạo ra nội dung mới Đạt được mục tiêu cụ thể trong môi trường Hành động Tạo ra văn bản, hình ảnh, âm thanh, video, code Ra quyết định và thực hiện hành động Ví dụ ChatGPT, DALL-E 2, GitHub Copilot Hệ thống điều khiển tự động, robot hút bụi, hệ thống gợi ý sản phẩm Ứng dụng Backend Tạo tài liệu API, tạo mock data, tạo code boilerplate Giám sát hệ thống, phát hiện lỗi, phản hồi sự cố Kết luận Generative AI và AI Agent là hai loại hình AI khác nhau với những mục tiêu và ứng dụng riêng. Hiểu rõ sự khác biệt giữa chúng sẽ giúp các lập trình viên backend tận dụng tối đa tiềm năng của AI để giải quyết các bài toán thực tế và nâng cao hiệu quả công việc. Trong tương lai, chúng ta có thể thấy sự kết hợp giữa Generative AI và AI Agent, ví dụ như một AI Agent sử dụng Generative AI để tạo ra các kế hoạch hành động chi tiết.\n","permalink":"https://thanhhv.github.io/ai/generative-ai-vs-ai-agent/","summary":"\u003ch2 id=\"generative-ai-và-ai-agent-hiểu-rõ-sự-khác-biệt-cho-backend-developers\"\u003eGenerative AI và AI Agent: Hiểu rõ sự khác biệt cho Backend Developers\u003c/h2\u003e\n\u003cp\u003eTrong thế giới AI đang phát triển nhanh chóng, hai khái niệm \u0026ldquo;Generative AI\u0026rdquo; và \u0026ldquo;AI Agent\u0026rdquo; thường được nhắc đến. Bài viết này sẽ giúp các lập trình viên backend phân biệt rõ hai loại hình AI này một cách dễ hiểu.\u003c/p\u003e\n\u003ch3 id=\"generative-ai-là-gì\"\u003eGenerative AI là gì?\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eGenerative AI\u003c/strong\u003e (AI tạo sinh) là một loại AI có khả năng tạo ra nội dung mới. Nội dung này có thể là văn bản, hình ảnh, âm thanh, video, hoặc thậm chí là code.\u003c/p\u003e","title":"Phân biệt Generative AI và AI Agent cho Lập trình viên Backend"},{"content":"Genesis Block: So Sánh Bitcoin và Ethereum Genesis Block, hay Block 0, là khối đầu tiên trong một blockchain. Nó đóng vai trò là nền tảng, đặt nền móng cho toàn bộ mạng lưới. Mặc dù cả Bitcoin và Ethereum đều có Genesis Block, nhưng có những khác biệt quan trọng về cách chúng được tạo ra và dữ liệu chúng chứa.\nGenesis Block của Bitcoin Hardcoded: Genesis Block của Bitcoin được hardcoded trực tiếp vào mã nguồn của Bitcoin Core. Điều này có nghĩa là nó không được khai thác như các block sau này. Message: Chứa một thông điệp ẩn: \u0026quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\u0026quot;. Thông điệp này được cho là một dấu mốc thời gian, đồng thời là một lời chỉ trích hệ thống ngân hàng truyền thống. Difficulty: Có độ khó (difficulty) bằng 1, độ khó thấp nhất có thể. Nonce: Giá trị nonce được tìm thấy bằng cách brute-force, thử nhiều giá trị khác nhau cho đến khi tìm thấy một hash hợp lệ. Reward: Phần thưởng cho việc \u0026ldquo;khai thác\u0026rdquo; Genesis Block (50 BTC) không thể sử dụng được. Transaction này tồn tại, nhưng không thể chi tiêu. Genesis Block của Ethereum Không Hardcoded: Genesis Block của Ethereum không được hardcoded vào mã nguồn. Thay vào đó, nó được tạo ra thông qua một file JSON cấu hình. Điều này cho phép các blockchain Ethereum riêng tư hoặc thử nghiệm có thể dễ dàng tạo genesis block của riêng họ. State: Genesis Block của Ethereum không chỉ chứa thông tin về block, mà còn chứa trạng thái ban đầu của tài khoản. Điều này bao gồm số dư của các tài khoản ban đầu. Mix Hash và Nonce: Genesis Block của Ethereum có một mix hash và nonce hợp lệ, nhưng chúng không được tạo ra thông qua quá trình proof-of-work. Chúng được đặt thủ công. Difficulty: Genesis block của Ethereum có độ khó thấp, nhưng không nhất thiết phải là độ khó thấp nhất. Tóm tắt so sánh Tính năng Bitcoin Ethereum Hardcoded Có Không Message Có (dòng tiêu đề báo) Không State Không Có (trạng thái tài khoản ban đầu) Khai thác Không (hardcoded) Không (tạo bằng file JSON) Phần thưởng Không thể chi tiêu Không có Kết luận Genesis Block của Bitcoin và Ethereum, mặc dù đều là khối đầu tiên của blockchain, nhưng lại có những khác biệt đáng kể về cách chúng được tạo ra và dữ liệu chúng chứa. Sự khác biệt này phản ánh sự khác biệt về triết lý thiết kế và mục tiêu của hai blockchain này. Bitcoin tập trung vào sự đơn giản và phi tập trung, trong khi Ethereum tập trung vào tính linh hoạt và khả năng mở rộng.\n","permalink":"https://thanhhv.github.io/ai/genesis-block-bitcoin-vs-ethereum/","summary":"\u003ch1 id=\"genesis-block-so-sánh-bitcoin-và-ethereum\"\u003eGenesis Block: So Sánh Bitcoin và Ethereum\u003c/h1\u003e\n\u003cp\u003eGenesis Block, hay Block 0, là khối đầu tiên trong một blockchain. Nó đóng vai trò là nền tảng, đặt nền móng cho toàn bộ mạng lưới. Mặc dù cả Bitcoin và Ethereum đều có Genesis Block, nhưng có những khác biệt quan trọng về cách chúng được tạo ra và dữ liệu chúng chứa.\u003c/p\u003e\n\u003ch2 id=\"genesis-block-của-bitcoin\"\u003eGenesis Block của Bitcoin\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHardcoded:\u003c/strong\u003e Genesis Block của Bitcoin được hardcoded trực tiếp vào mã nguồn của Bitcoin Core. Điều này có nghĩa là nó không được khai thác như các block sau này.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMessage:\u003c/strong\u003e Chứa một thông điệp ẩn: \u003ccode\u003e\u0026quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\u0026quot;\u003c/code\u003e. Thông điệp này được cho là một dấu mốc thời gian, đồng thời là một lời chỉ trích hệ thống ngân hàng truyền thống.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDifficulty:\u003c/strong\u003e Có độ khó (difficulty) bằng 1, độ khó thấp nhất có thể.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNonce:\u003c/strong\u003e Giá trị nonce được tìm thấy bằng cách brute-force, thử nhiều giá trị khác nhau cho đến khi tìm thấy một hash hợp lệ.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReward:\u003c/strong\u003e Phần thưởng cho việc \u0026ldquo;khai thác\u0026rdquo; Genesis Block (50 BTC) không thể sử dụng được. Transaction này tồn tại, nhưng không thể chi tiêu.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"genesis-block-của-ethereum\"\u003eGenesis Block của Ethereum\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKhông Hardcoded:\u003c/strong\u003e Genesis Block của Ethereum không được hardcoded vào mã nguồn. Thay vào đó, nó được tạo ra thông qua một file JSON cấu hình. Điều này cho phép các blockchain Ethereum riêng tư hoặc thử nghiệm có thể dễ dàng tạo genesis block của riêng họ.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eState:\u003c/strong\u003e Genesis Block của Ethereum không chỉ chứa thông tin về block, mà còn chứa trạng thái ban đầu của tài khoản. Điều này bao gồm số dư của các tài khoản ban đầu.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMix Hash và Nonce:\u003c/strong\u003e Genesis Block của Ethereum có một mix hash và nonce hợp lệ, nhưng chúng không được tạo ra thông qua quá trình proof-of-work. Chúng được đặt thủ công.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDifficulty:\u003c/strong\u003e Genesis block của Ethereum có độ khó thấp, nhưng không nhất thiết phải là độ khó thấp nhất.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tóm-tắt-so-sánh\"\u003eTóm tắt so sánh\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eTính năng\u003c/th\u003e\n          \u003cth\u003eBitcoin\u003c/th\u003e\n          \u003cth\u003eEthereum\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eHardcoded\u003c/td\u003e\n          \u003ctd\u003eCó\u003c/td\u003e\n          \u003ctd\u003eKhông\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMessage\u003c/td\u003e\n          \u003ctd\u003eCó (dòng tiêu đề báo)\u003c/td\u003e\n          \u003ctd\u003eKhông\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eState\u003c/td\u003e\n          \u003ctd\u003eKhông\u003c/td\u003e\n          \u003ctd\u003eCó (trạng thái tài khoản ban đầu)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eKhai thác\u003c/td\u003e\n          \u003ctd\u003eKhông (hardcoded)\u003c/td\u003e\n          \u003ctd\u003eKhông (tạo bằng file JSON)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePhần thưởng\u003c/td\u003e\n          \u003ctd\u003eKhông thể chi tiêu\u003c/td\u003e\n          \u003ctd\u003eKhông có\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"kết-luận\"\u003eKết luận\u003c/h2\u003e\n\u003cp\u003eGenesis Block của Bitcoin và Ethereum, mặc dù đều là khối đầu tiên của blockchain, nhưng lại có những khác biệt đáng kể về cách chúng được tạo ra và dữ liệu chúng chứa. Sự khác biệt này phản ánh sự khác biệt về triết lý thiết kế và mục tiêu của hai blockchain này. Bitcoin tập trung vào sự đơn giản và phi tập trung, trong khi Ethereum tập trung vào tính linh hoạt và khả năng mở rộng.\u003c/p\u003e","title":"Sự Khác Biệt Giữa Genesis Block của Bitcoin và Ethereum"},{"content":"👨‍💻 Hoang Van Thanh - Backend Engineer 📍 Thu Duc, Ho Chi Minh City, Vietnam 📞 0332 *** 362 📧 Email: thanhhv317@gmail.com 🐙 GitHub: @thanhhv 🔗 LinkedIn: linkedin.com/in/thanhhv317 📅 DOB: 11/08/1998 🛠 Skills Languages \u0026amp; Frameworks: Node.js, Go, TypeScript, JavaScript, Express, NestJS Architecture: Microservices, Message Queue, Clean Architecture, WebSocket Databases: MongoDB, PostgreSQL, Redis Blockchain: Web3.js, ethers, On-chain Data DevOps \u0026amp; Tools: Docker, AWS (EC2, S3, Lambda, SQS), Prometheus, Grafana, Kibana Testing \u0026amp; Monitoring: Jest, Jaeger, Tracing, n8n Others: HTML, CSS, Bootstrap, React.js, CI/CD, GitHub, Linux Soft Skills: Problem solving, Teamwork Languages: English 💼 Experience Coin98 (9/2023 - 4/2025) Project: AmberBlocks - Blockchain CMS platform\nDesigned databases for tags, courses, series, etc. Implemented Meilisearch for full-text search Developed services for core business logic Wrote unit tests and participated in agile sprints Project: OneID \u0026amp; KYC - Blockchain-based identity solution\nDesigned databases and handled smart contract integration Built modules for KYC/KYB and payment tracking Project: Superwallet Market Service\nMigrated JS → TS, refactored services Integrated CoinGecko and Debank APIs Provided analytics and market tracking Finviet Technology Corporation (10/2020 - 9/2023) Project: Loyalty - Scalable system for transaction-based point rewards\nArchitected databases and microservices Integrated monitoring with Prometheus \u0026amp; Grafana Wrote dashboards and optimized MongoDB queries Project: Eco Consumer App\nBuilt backend for wallet, loyalty, payments Integrated WebSocket and third-party services Generated business reports and system schedulers Project: Eco CMS Service\nIntegrated bill payment and refactored backend logic Eplus Solution \u0026amp; Technology (5/2019 - 9/2020) Internship → Fresher Developer\nBuilt backend using Go and Node.js Participated in Agile development, unit testing Helped with HTML-to-PDF extraction and frontend integration 🎓 Education Ho Chi Minh University of Education (2016 - 2020)\nFaculty of Information Technology\n🎯 About Me I\u0026rsquo;m a passionate backend developer seeking opportunities to grow, contribute, and build scalable, secure, and impactful systems - especially in Web3 and cloud-based platforms. I love learning system design, building microservices, and optimizing infrastructure.\n📂 Projects \u0026amp; Links Blog: thanhhv.github.io GitHub: thanhhv Last updated: 2024-04-23\n","permalink":"https://thanhhv.github.io/cv/","summary":"\u003ch2 id=\"-hoang-van-thanh---backend-engineer\"\u003e👨‍💻 Hoang Van Thanh - Backend Engineer\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e📍 Thu Duc, Ho Chi Minh City, Vietnam\u003c/li\u003e\n\u003cli\u003e📞 0332 *** 362\u003c/li\u003e\n\u003cli\u003e📧 Email: \u003ca href=\"mailto:thanhhv317@gmail.com\"\u003ethanhhv317@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e🐙 GitHub: \u003ca href=\"https://github.com/thanhhv\"\u003e@thanhhv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e🔗 LinkedIn: \u003ca href=\"https://www.linkedin.com/in/thanhhv317/\"\u003elinkedin.com/in/thanhhv317\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e📅 DOB: 11/08/1998\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"-skills\"\u003e🛠 Skills\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages \u0026amp; Frameworks\u003c/strong\u003e: Node.js, Go, TypeScript, JavaScript, Express, NestJS\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eArchitecture\u003c/strong\u003e: Microservices, Message Queue, Clean Architecture, WebSocket\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDatabases\u003c/strong\u003e: MongoDB, PostgreSQL, Redis\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBlockchain\u003c/strong\u003e: Web3.js, ethers, On-chain Data\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDevOps \u0026amp; Tools\u003c/strong\u003e: Docker, AWS (EC2, S3, Lambda, SQS), Prometheus, Grafana, Kibana\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTesting \u0026amp; Monitoring\u003c/strong\u003e: Jest, Jaeger, Tracing, n8n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOthers\u003c/strong\u003e: HTML, CSS, Bootstrap, React.js, CI/CD, GitHub, Linux\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSoft Skills\u003c/strong\u003e: Problem solving, Teamwork\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages\u003c/strong\u003e: English\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"-experience\"\u003e💼 Experience\u003c/h3\u003e\n\u003ch4 id=\"coin98-92023---42025\"\u003eCoin98 (9/2023 - 4/2025)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eProject: AmberBlocks\u003c/strong\u003e - Blockchain CMS platform\u003c/p\u003e","title":"Curriculum Vitae"},{"content":" 🎯 Goal: Ensure the system is stable, scalable, and production-ready before launching.\n🧱 I. CODE \u0026amp; FUNCTIONAL Code reviewed and approved by at least one senior developer Unit test coverage ≥ 80% Edge cases handled properly No N+1 queries (GraphQL/ORM optimized) No leftover console.log or debugger in code No secrets or tokens hardcoded 🚦 II. CI/CD \u0026amp; DEPLOYMENT CI pipeline set up (build → test → deploy) Rollback plan in place (script or quick revert strategy) Staging/UAT environment available and tested .env variables configured correctly (not copied from local) Proper branch/tag naming (e.g. release/v1.0.0) 🔒 III. SECURITY Auth applied on all sensitive routes (JWT, OAuth, API keys) Role \u0026amp; permission system tested No publicly exposed sensitive endpoints (/admin, /debug) Checked for XSS, SQLi, path traversal vulnerabilities Rate limiting/throttling in place for public APIs Security headers enabled (helmet, CORS, etc.) 📈 IV. PERFORMANCE \u0026amp; SCALING Load tested for target RPS (e.g. ≥ 10k req/s) Concurrent users simulated (e.g. 1k logins) DB indexed properly (EXPLAIN ANALYZE used) Redis, CDN, or in-memory caching applied File/media offloaded to external storage (e.g. S3) API only returns necessary data (REST/GraphQL select) 🧠 V. MONITORING \u0026amp; ALERTING Logging integrated (Winston, Pino, ELK, Datadog, etc.) Logs include traceId, userId, route context Metrics collection: Prometheus / Grafana / OpenTelemetry Alert configured for: High error rate (5xx) CPU \u0026gt; 80% Memory full Queue backlog increasing ⚙️ VI. INFRASTRUCTURE Load balancer configured and stable Auto-restart and healthcheck ready (PM2, Docker, k8s readiness) Database backup and restore tested Horizontal scaling/pod autoscaling set up if using k8s .env.production encrypted or managed via Vault 📋 VII. OTHER Changelog written (CHANGELOG.md) Release announcement sent to relevant teams Post-deploy checklist created (Smoke test UI/API) QA checklist completed (login, checkout, error, etc.) Graceful fallback UI for error handling /status, /health, /metrics, /version endpoints ready ✅ READY TO GO LIVE? Goal Ready? Code clean and stable ✅ Load test passed ✅ Monitoring in place ✅ Rollback plan confirmed ✅ Stakeholders notified ✅ 🔁 POST GO-LIVE ACTIONS Real-time system monitoring active User feedback monitored Latency/error rate observed 24h go-live report or postmortem (if needed) ","permalink":"https://thanhhv.github.io/wiki/go-live-checklist/","summary":"\u003cblockquote\u003e\n\u003cp\u003e🎯 \u003cstrong\u003eGoal:\u003c/strong\u003e Ensure the system is stable, scalable, and production-ready before launching.\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-i-code--functional\"\u003e🧱 I. CODE \u0026amp; FUNCTIONAL\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Code reviewed and approved by at least one senior developer\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Unit test coverage ≥ 80%\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Edge cases handled properly\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No N+1 queries (GraphQL/ORM optimized)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No leftover \u003ccode\u003econsole.log\u003c/code\u003e or \u003ccode\u003edebugger\u003c/code\u003e in code\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No secrets or tokens hardcoded\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-ii-cicd--deployment\"\u003e🚦 II. CI/CD \u0026amp; DEPLOYMENT\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e CI pipeline set up (build → test → deploy)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Rollback plan in place (script or quick revert strategy)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Staging/UAT environment available and tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e.env\u003c/code\u003e variables configured correctly (not copied from local)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Proper branch/tag naming (e.g. \u003ccode\u003erelease/v1.0.0\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-iii-security\"\u003e🔒 III. SECURITY\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Auth applied on all sensitive routes (JWT, OAuth, API keys)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Role \u0026amp; permission system tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No publicly exposed sensitive endpoints (\u003ccode\u003e/admin\u003c/code\u003e, \u003ccode\u003e/debug\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Checked for XSS, SQLi, path traversal vulnerabilities\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Rate limiting/throttling in place for public APIs\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Security headers enabled (\u003ccode\u003ehelmet\u003c/code\u003e, CORS, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-iv-performance--scaling\"\u003e📈 IV. PERFORMANCE \u0026amp; SCALING\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Load tested for target RPS (e.g. ≥ 10k req/s)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Concurrent users simulated (e.g. 1k logins)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e DB indexed properly (\u003ccode\u003eEXPLAIN ANALYZE\u003c/code\u003e used)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Redis, CDN, or in-memory caching applied\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e File/media offloaded to external storage (e.g. S3)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e API only returns necessary data (REST/GraphQL select)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-v-monitoring--alerting\"\u003e🧠 V. MONITORING \u0026amp; ALERTING\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Logging integrated (Winston, Pino, ELK, Datadog, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Logs include traceId, userId, route context\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Metrics collection: Prometheus / Grafana / OpenTelemetry\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Alert configured for:\n\u003cul\u003e\n\u003cli\u003eHigh error rate (5xx)\u003c/li\u003e\n\u003cli\u003eCPU \u0026gt; 80%\u003c/li\u003e\n\u003cli\u003eMemory full\u003c/li\u003e\n\u003cli\u003eQueue backlog increasing\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-vi-infrastructure\"\u003e⚙️ VI. INFRASTRUCTURE\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Load balancer configured and stable\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Auto-restart and healthcheck ready (PM2, Docker, k8s readiness)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Database backup and restore tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Horizontal scaling/pod autoscaling set up if using k8s\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e.env.production\u003c/code\u003e encrypted or managed via Vault\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-vii-other\"\u003e📋 VII. OTHER\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Changelog written (\u003ccode\u003eCHANGELOG.md\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Release announcement sent to relevant teams\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Post-deploy checklist created (Smoke test UI/API)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e QA checklist completed (login, checkout, error, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Graceful fallback UI for error handling\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e/status\u003c/code\u003e, \u003ccode\u003e/health\u003c/code\u003e, \u003ccode\u003e/metrics\u003c/code\u003e, \u003ccode\u003e/version\u003c/code\u003e endpoints ready\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-ready-to-go-live\"\u003e✅ READY TO GO LIVE?\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eGoal\u003c/th\u003e\n          \u003cth\u003eReady?\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCode clean and stable\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eLoad test passed\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMonitoring in place\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRollback plan confirmed\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eStakeholders notified\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"-post-go-live-actions\"\u003e🔁 POST GO-LIVE ACTIONS\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Real-time system monitoring active\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e User feedback monitored\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Latency/error rate observed\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 24h go-live report or postmortem (if needed)\u003c/li\u003e\n\u003c/ul\u003e","title":"Go-live load test \u0026 deployment checklist"},{"content":"Reading is not only for fun, but also to develop clear thinking and deeper perspective.\nHere\u0026rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.\n📘 Psychology \u0026amp; Thinking Thinking, Fast and Slow - Daniel Kahneman The One Thing - Gary W. Keller, Jay Papasan 🌍 Philosophy \u0026amp; Life Naval Ravikant: Để thịnh vượng và hạnh phúc - Eric Jorgenson \u0026hellip; will be updated more\n","permalink":"https://thanhhv.github.io/wiki/non-tech-books-worth-reading/","summary":"\u003cp\u003eReading is not only for fun, but also to develop clear thinking and deeper perspective.\u003cbr\u003e\nHere\u0026rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.\u003c/p\u003e\n\u003ch2 id=\"-psychology--thinking\"\u003e📘 Psychology \u0026amp; Thinking\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eThinking, Fast and Slow\u003c/em\u003e - Daniel Kahneman\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eThe One Thing\u003c/em\u003e - Gary W. Keller, Jay Papasan\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"-philosophy--life\"\u003e🌍 Philosophy \u0026amp; Life\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eNaval Ravikant: Để thịnh vượng và hạnh phúc\u003c/em\u003e - Eric Jorgenson\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026hellip; will be updated more\u003c/p\u003e","title":"Non-Tech Books Worth Reading"}]
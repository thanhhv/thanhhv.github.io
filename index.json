[{"content":"Hợp đồng thông minh DEX Trong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: Factory, Router, và Pair. Vai trò của từng hợp đồng như sau:\n🔹 1. Factory Contract Là nơi đăng ký chính của các pool thanh khoản (cặp token). Tạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới. Lưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng. Các hàm chính:\ncreatePair(tokenA, tokenB): Triển khai hợp đồng Pair mới cho cặp tokenA và tokenB. getPair(tokenA, tokenB): Trả về địa chỉ hợp đồng Pair. allPairs(): Trả về danh sách tất cả các cặp đã tạo. Ví dụ:\nNếu người dùng muốn giao dịch Token A ↔ Token B mà chưa có pool, Factory sẽ tạo hợp đồng Pair mới.\n🔹 2. Router Contract Là hợp đồng chính mà người dùng tương tác để hoán đổi token, thêm/bớt thanh khoản và định tuyến giao dịch. Gọi đến Factory để tìm hợp đồng Pair tương ứng. Đảm bảo giá tốt nhất bằng cách định tuyến giao dịch qua nhiều cặp token. Các hàm chính:\nswapExactTokensForTokens(amountIn, minAmountOut, path, recipient, deadline): Hoán đổi amountIn của Token A sang Token B. addLiquidity(tokenA, tokenB, amountA, amountB, minA, minB, to, deadline): Thêm thanh khoản vào một Pair. removeLiquidity(tokenA, tokenB, liquidity, minA, minB, to, deadline): Rút thanh khoản khỏi Pair. Ví dụ:\nNgười dùng muốn đổi Token A sang Token B:\nRouter kiểm tra tuyến giao dịch tối ưu (trực tiếp hoặc qua nhiều cặp). Gọi đến hợp đồng Pair để thực hiện giao dịch. Token được chuyển giao tương ứng. 🔹 3. Pair Contract (Liquidity Pool) Quản lý pool thanh khoản cho một cặp token. Sử dụng công thức AMM sản phẩm không đổi:\nx * y = k\nTrong đó x và y là lượng token dự trữ, k là hằng số không đổi. Các hàm chính:\nswap(amount0Out, amount1Out, to): Thực hiện hoán đổi token. mint(to): Mint token LP (liquidity provider). burn(to): Burn token LP và trả lại token gốc. getReserves(): Trả về lượng token dự trữ. Ví dụ:\nNếu có giao dịch Token A → Token B:\nNgười dùng gửi Token A vào hợp đồng Pair. Pair tính toán số Token B trả lại dựa vào công thức AMM. Gửi Token B cho người dùng, cập nhật dự trữ. 🛠 Các hợp đồng khác trong DEX 🔹 4. Multicall Contract (tùy chọn) Cho phép thực hiện nhiều lệnh gọi hợp đồng trong một giao dịch (ví dụ: kiểm tra nhiều giá cùng lúc). 🔹 5. Fee Collection Contract (tùy chọn) Nếu DEX thu phí giao thức, sẽ có hợp đồng riêng để thu và phân phối phí. 🎯 Cách các hợp đồng phối hợp với nhau Tạo cặp token mới:\nFactory triển khai hợp đồng Pair nếu chưa tồn tại. Thêm thanh khoản:\nNgười dùng gọi Router, Router nạp token vào Pair contract. Người dùng nhận lại token LP. Hoán đổi token:\nNgười dùng gọi Router để hoán đổi. Router tìm đúng Pair và thực hiện swap. Rút thanh khoản:\nNgười dùng trả lại token LP cho Router, Router rút tài sản từ Pair. 🚀 Ví dụ luồng swap Giả sử bạn muốn hoán đổi 100 USDT → ETH trên DEX:\nNgười dùng gọi:\nswapExactTokensForTokens(100 USDT, minETH, [USDT, ETH], recipient, deadline) Router truy xuất hợp đồng Pair (USDT/ETH) từ Factory. Pair tính toán số ETH trả lại theo công thức AMM. Gửi ETH cho người dùng, USDT thêm vào dự trữ. 🔥 Tổng kết Hợp đồng Mục đích Factory Tạo và theo dõi các hợp đồng Pair (pool thanh khoản). Router Xử lý swap, định tuyến, quản lý thanh khoản. Pair Giữ token dự trữ, thực hiện swap theo AMM. Multicall (tuỳ chọn) Gộp nhiều lệnh gọi hợp đồng thành một giao dịch. Fee Collection (tuỳ chọn) Thu và phân phối phí giao thức. Uniswap V2 - Công thức sản phẩm không đổi và cách tính giá Uniswap V2 hoạt động theo mô hình AMM (Automated Market Maker), nơi tính thanh khoản trong pool được duy trì bởi công thức sản phẩm không đổi:\nx * y = k\nTrong đó:\nx = Số lượng Token X trong pool y = Số lượng Token Y trong pool k = Hằng số không đổi sau mỗi giao dịch Ví dụ:\nToken X là ETH Token Y là USDT Thiết lập ban đầu Pool có:\n1000 ETH 500,000 USDT k = 1000 * 500,000 = 500,000,000\nBước 1: Tính giá ban đầu Giá ETH theo USDT:\n1 ETH = 500 USDT\nBước 2: Giao dịch swap Người dùng swap 100 ETH → USDT\nETH trong pool: 1000 → 1100\nUSDT giảm để giữ k = 500,000,000\nBước 3: Tính USDT mới 1100 * y' = 500,000,000 → y' = 454,545.45 USDT\nBước 4: Tính số USDT nhận được 500,000 - 454,545.45 = 45,454.55 USDT\nBước 5: Giá ETH mới 1 ETH ≈ 412.37 USDT\nTóm tắt Trạng thái ETH USDT Giá ETH Trước swap 1000 500,000 500 USDT Sau swap 1100 454,545.45 412.37 USDT Kết luận Tác động giá: Giá ETH giảm vì tỉ lệ thay đổi. Sản phẩm không đổi: k không đổi, đảm bảo thanh khoản. Lợi ích LP: Kiếm phí nhưng có nguy cơ tổn thất tạm thời. Bài viết được mình dịch từ duyquoc1508, cám ơn Quốc vì đã có 1 bài viết quá chi tiết này.\n","permalink":"https://thanhhv.github.io/posts/dex/","summary":"\u003ch2 id=\"hợp-đồng-thông-minh-dex\"\u003eHợp đồng thông minh DEX\u003c/h2\u003e\n\u003cp\u003eTrong một sàn giao dịch phi tập trung (DEX) như Uniswap, nhiều hợp đồng thông minh làm việc cùng nhau để cho phép hoán đổi token. Các hợp đồng chính thường bao gồm: \u003cstrong\u003eFactory\u003c/strong\u003e, \u003cstrong\u003eRouter\u003c/strong\u003e, và \u003cstrong\u003ePair\u003c/strong\u003e. Vai trò của từng hợp đồng như sau:\u003c/p\u003e\n\u003ch3 id=\"-1-factory-contract\"\u003e🔹 1. Factory Contract\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLà nơi đăng ký chính của các pool thanh khoản (cặp token).\u003c/li\u003e\n\u003cli\u003eTạo ra pool thanh khoản mới khi có thêm cặp giao dịch mới.\u003c/li\u003e\n\u003cli\u003eLưu trữ ánh xạ giữa các cặp token và địa chỉ của hợp đồng Pair tương ứng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCác hàm chính:\u003c/strong\u003e\u003c/p\u003e","title":"Tổng quan về Hợp đồng Thông minh trong DEX và AMM"},{"content":"Bạn đang tìm kiếm một web server open source mới, mạnh mẽ và dễ sử dụng? Hãy cùng khám phá Candyserver!\nCandyserver là một web server mới nổi, được xây dựng với mục tiêu cung cấp hiệu suất cao, tính linh hoạt và trải nghiệm người dùng thân thiện. Mặc dù còn khá mới, Candyserver đã thu hút sự chú ý của cộng đồng open source nhờ những ưu điểm sau:\nHiệu suất: Candyserver được tối ưu hóa để xử lý lượng lớn request một cách hiệu quả, giúp website của bạn hoạt động mượt mà ngay cả khi có nhiều người truy cập. Dễ cấu hình: Giao diện cấu hình đơn giản và trực quan giúp bạn dễ dàng cài đặt và tùy chỉnh Candyserver theo nhu cầu của mình. Tính năng: Candyserver hỗ trợ nhiều tính năng quan trọng như HTTPS, HTTP/2, reverse proxy, load balancing, và nhiều hơn nữa. Open Source: Được phát triển dưới giấy phép open source, Candyserver mang lại sự minh bạch và khả năng tùy chỉnh cao cho người dùng. Cộng đồng: Mặc dù còn non trẻ, Candyserver đã có một cộng đồng người dùng và nhà phát triển đang phát triển nhanh chóng, sẵn sàng hỗ trợ và chia sẻ kinh nghiệm. Nếu bạn đang tìm kiếm một web server open source thay thế cho các lựa chọn truyền thống, Candyserver là một ứng cử viên đáng để thử. Hãy truy cập trang web chính thức của Candyserver để tìm hiểu thêm về cách cài đặt, cấu hình và sử dụng.\nBạn nghĩ gì về Candyserver? Hãy chia sẻ ý kiến của bạn trong phần bình luận bên dưới!\n","permalink":"https://thanhhv.github.io/ai/candyserver-web-server-open-source/","summary":"\u003cp\u003eBạn đang tìm kiếm một web server open source mới, mạnh mẽ và dễ sử dụng? Hãy cùng khám phá Candyserver!\u003c/p\u003e\n\u003cp\u003eCandyserver là một web server mới nổi, được xây dựng với mục tiêu cung cấp hiệu suất cao, tính linh hoạt và trải nghiệm người dùng thân thiện. Mặc dù còn khá mới, Candyserver đã thu hút sự chú ý của cộng đồng open source nhờ những ưu điểm sau:\u003c/p\u003e","title":"Giới thiệu Candyserver: Web Server Open Source Mới Đầy Hứa Hẹn"},{"content":"Xin chào mọi người,\nTrong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có Node.js và Golang. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let\u0026rsquo;s start!\n1. Hiệu năng và Đa luồng Golang có hiệu năng tốt hơn nhờ là compiled language và mô hình goroutine rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.\nNode.js dùng event loop, rất hiệu quả cho ứng dụng I/O-bound, nhưng dễ bị nghẽn khi xử lý CPU-bound do chạy đơn luồng (có thể dùng worker threads nhưng không phải là mặc định).\nVậy nên, nếu hệ thống cần xử lý song song, real-time, high concurrency → Golang là lựa chọn tốt.\nMình sẽ chú thích thêm 1 xíu về I/O-bound và CPU-bound là gì cho mọi người dễ follow nhé:\nI/O-bound: là tác vụ mà CPU phải chờ dữ liệu từ ngoài: đọc file, query DB, gởi request network\u0026hellip;\nawait fetch(\u0026#39;https://api.example.com/data\u0026#39;) CPU-bound: là tác vụ sử dụng nhiều CPU, như tính toán, mã hoá, AI\u0026hellip;\nfor (let i = 0; i \u0026lt; 1e9; i++) { // Tính toán số nguyên tố } 2. Tốc độ phát triển \u0026amp; Hệ sinh thái Node.js: ecosystem mạnh, npm phong phú, build nhanh, nhất là khi làm với frontend (JS/TS). Golang: code rõ ràng, nhưng viết nhiều hơn vì ít thư viện có sẵn. Nên nếu cần tốc độ phát triển nhanh → Nodejs là lựa chọn tốt.\n3. Maintainability \u0026amp; Readability Golang: strict typing, clear structure → dễ maintain trong team. Node.js: Typescript thì ổn, JavaScript thuần thì dễ sinh bug. Nên dự án quy mô lớn → Golang tốt hơn về dài hạn.\n4. Use Case thực tế Dự án DEX:\nGolang cho core server xử lý thuật toán tìm đường đi tối ưu nhất giữa các pool để swap token (CPU-bound). Node.js cho crawler/router (I/O-bound). Dự án web/blog:\nNode.js phù hợp do chủ yếu fetch dữ liệu DB trả về. 5. Khả năng xử lý I/O Thực ra Golang cũng xử lý I/O bất đồng bộ rất tốn nhờ goroutines và non-blocking calls. Nhưng có lý do tại sao người ta vẫn nói Nodejs mạnh hơn về I/O, đặc biệt là trong các hệ thống I/O intensive (API gateway, proxy server)\nYếu tố Node.js Golang I/O Handling Event loop + libuv + Non-blocking I/O Goroutine + epoll/kqueue (runtime quản lý) Concurrency Model Single-threaded với event loop Multi-threaded với goroutines Resource Usage Ít RAM (1 thread chính + thread pool khi cần) Nhẹ (goroutines ~2KB stack size) I/O Performance Cực nhanh cho I/O nhỏ Tốt nhưng có overhead khi nhiều goroutines Throughput Rất cao với lượng request nhỏ, nhanh Ổn định với request lớn, dài hạn Nodejs có event-loop hoạt động mạnh như disptacher trung tâm: Request nhỏ (đọc file, query db, network) được đưa và libuv. Không cần tạo thread mới -\u0026gt; do là single thread , chỉ cần 1 thread chính để quản lý mọi thứ. callback-based -\u0026gt; event loop chỉ cần biết là khi nào I/O xong để tiếp tục xử lý. Kết quả: với lượng I/O nhỏ và nhanh, nodejs cực kì nhanh và không bị lãng phí tài nguyên so với việc tạo goroutines/thread không cần thiết. Go thì khác: mỗi request sẽ tạo 1 goroutine (nhẹ, những vẫn là context riêng) Runtime của go quản lý goroutines bằng M:N Scheduler (map nhiều goroutines vào ít thread) Nếu request nhiều quá, runtime phải liên tục schedule và switch context -\u0026gt; có overhead dù nhỏ. Kết quả: với lượng I/O nhỏ, liên tục, việc context swiching quá nhiều có thể làm giảm hiệu suất so với nodejs. Khi nào Node.js vượt trội? API gateway (hàng triệu request/ngày) Chat app, notification Proxy server Streaming app (WebSocket, video chunks) ✅ I/O-heavy → Node.js\n✅ CPU-heavy → Golang\nNói chung cả Nodejs và Golang đều rất mạnh mẽ, nhưng chúng phù hợp với từng usecase khác nhau. Chúng ta nên quan trọng việc chọn đúng công cụ cho bài toán hơn là chỉ chọn theo sở thích cá nhân.\nCảm ơn bạn đã đọc đến đây. Hẹn gặp lại trong bài viết tiếp theo nhé! 🙌\n","permalink":"https://thanhhv.github.io/posts/nodejs-vs-go/","summary":"\u003cp\u003eXin chào mọi người,\u003c/p\u003e\n\u003cp\u003eTrong quá trình làm việc ở vị trí Backend Engineer, mình đã trải qua nhiều ngôn ngữ lập trình, trong đó có \u003cstrong\u003eNode.js\u003c/strong\u003e và \u003cstrong\u003eGolang\u003c/strong\u003e. Vậy trường hợp nào nên dùng Node.js, trường hợp nào nên dùng Golang? Bài viết này chia sẻ kinh nghiệm thực chiến cá nhân và quan sát thực tế từ đồng nghiệp xung quanh. Let\u0026rsquo;s start!\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Nodejs-vs-Golang\" loading=\"lazy\" src=\"/posts/nodejs-vs-go/nodejs-go.png\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-hiệu-năng-và-đa-luồng\"\u003e1. Hiệu năng và Đa luồng\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eGolang\u003c/strong\u003e có hiệu năng tốt hơn nhờ là compiled language và mô hình \u003cstrong\u003egoroutine\u003c/strong\u003e rất nhẹ (lightweight thread do Go runtime quản lý), dễ dàng xử lý hàng nghìn concurrent connections mà tốn rất ít tài nguyên.\u003c/p\u003e","title":"So sánh Node.js và Golang trong Backend"},{"content":"Hôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,\u0026hellip;). Cùng bắt đầu nhé! Quá trình này gồm 3 bước đơn giản:\n1. Lấy message từ server Đầu tiên, client sẽ gửi request đến server để lấy message về. Đây là nội dung mà client sẽ ký bằng ví như Metamask để xác thực với dApp.\nVì message cần được thống nhất giữa server và client, nên server nên là bên tạo và quản lý message này.\nVí dụ message: thanhhv.github.io wants you to sign in with your Ethereum account: 0xA1B2...D3E4 Sign-in request for MyDApp URI: https://thanhhv.github.io Version: 1 Chain ID: 1 Nonce: 839174 Issued At: 2025-05-11T20:40:00Z Đây là định dạng theo EIP-4361 (Sign-In With Ethereum) được sử dụng phổ biến.\nNonce là số ngẫu nhiên dùng một lần (có thể dùng UUID), kết hợp với timestamp để tránh replay attack.\nServer nên tạo nonce, lưu vào database với các field:\nnonce, wallet, expiresAt, used = false, sau đó gắn vào message trả về cho client.\n2. Client ký message bằng private key Sau khi nhận được message, client sẽ dùng private key để ký.\nVí dụ sử dụng thư viện ethers:\nconst { ethers } = require(\u0026#34;ethers\u0026#34;); const wallet = new ethers.Wallet(process.env.PRIVATE_KEY); const signature = await wallet.signMessage(message); Client sau đó gửi { message, signature } về server.\n3. Server xác thực chữ ký Server sẽ:\nTách nonce từ message ra. Truy vấn DB để kiểm tra: Có tồn tại không? Hết hạn chưa? Đã được sử dụng chưa? Sau đó, dùng ethers để xác thực chữ ký:\nconst { ethers } = require(\u0026#34;ethers\u0026#34;); const recoveredAddress = ethers.utils.verifyMessage(message, signature); const isValid = recoveredAddress.toLowerCase() === addressFromRequest; Nếu hợp lệ, server có thể cập nhật DB: used = true, và cho phép đăng nhập thành công.\n4. Bonus: Kết hợp với JWT Giả sử bạn đang xây dựng trang quản trị admin, sau khi bước 3 hoàn tất, server có thể tạo 1 JWT token. Những request tiếp theo sẽ dùng token này để xác thực — giống như mô hình web2 quen thuộc.\nTuy là đăng nhập bằng ví crypto, nhưng sau đó bạn có thể tương tác với hệ thống như người dùng thông thường, vừa an toàn, vừa tiện lợi.\nHết rồi! Hy vọng bài viết hữu ích cho bạn nào đang tìm hiểu về Web3 authentication. Chúc cho tôi sẽ may mắn vượt qua vòng phỏng vấn sắp tới nhé, hihi 😄\n","permalink":"https://thanhhv.github.io/posts/verify-user-wallet/","summary":"\u003cp\u003eHôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,\u0026hellip;). Cùng bắt đầu nhé! Quá trình này gồm \u003cstrong\u003e3 bước đơn giản\u003c/strong\u003e:\u003c/p\u003e","title":"Xác thực người dùng bằng ví crypto"},{"content":"1. Cơ bản về cách blockchain thêm block Các blockchain như Ethereum, Bitcoin hoạt động như sau:\nMỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại. Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng. Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình. Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.\nGiả sử mạng lưới đang dừng ở block thứ 99. Miner A tìm ra block 100A và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block 100B và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.\nLúc này, blockchain tạo ra hai nhánh tạm thời (gọi là temporary fork) ở block thứ 100.\n2. Khi nào xảy ra re-org? Giả sử Miner C đào tiếp block 101 dựa trên 100B, chuỗi lúc này là:\nBlock 99 -\u0026gt; Block 100B -\u0026gt; Block 101 Trong khi đó, bạn đang theo chuỗi:\nBlock 99 -\u0026gt; Block 100A Theo quy tắc longest chain, blockchain sẽ chọn chuỗi dài hơn là chuỗi chính thức.\nVì vậy, chain 100B -\u0026gt; 101 sẽ được chấp nhận, và block 100A bị loại bỏ.\nQuá trình này gọi là chain reorganization (re-org).\nRe-org là lúc mà mạng đổi ý và chọn một nhánh mới dài hơn, bỏ qua nhánh cũ — giống như chơi cờ mà bỗng dưng đi lại nước trước đó vì thấy đường khác ngon hơn!\n3. Các kỹ thuật xử lý khi re-org xảy ra ở phía backend 3.1. Delay block confirmation Đây là cách phổ biến và đơn giản nhất.\nKhi indexing dữ liệu từ blockchain, bạn bỏ qua một vài block cuối cùng để tránh sai sót do re-org.\nVí dụ:\nTrên Ethereum, thường bỏ qua 12 block cuối (tức chỉ xử lý đến latest - 12). Các chain khác sẽ có con số riêng, bạn cần tra thêm tài liệu. Tuy nhiên, cách này có độ trễ nên có thể kèm theo giải pháp UI như:\n\u0026ldquo;Đang xử lý dữ liệu\u0026hellip; lần cập nhật gần nhất 1 phút trước\u0026rdquo;\n3.2. Xây dựng hệ thống rollback tự động (phức tạp hơn) Để dữ liệu gần như realtime nhưng vẫn chính xác, bạn có thể xây hệ thống hỗ trợ rollback khi re-org:\nKhi lưu dữ liệu từ block, luôn lưu kèm blockNumber và blockHash. Mỗi khi có block mới, kiểm tra lại N block trước đó (ví dụ: 12 block). Nếu blockHash không khớp với dữ liệu đã lưu: Rollback: xóa dữ liệu liên quan block cũ, sync lại block mới. Hoặc tạo record mới với trạng thái như: confirmed, reorged, replaced,\u0026hellip; để phục vụ audit. Phương pháp này chính xác hơn, nhưng phức tạp và tốn công hơn rất nhiều.\nViệc lựa chọn cách xử lý phù hợp nên linh hoạt tùy vào yêu cầu hệ thống và đặc thù sản phẩm bạn đang làm.\n👋 Kết Hy vọng bài viết giúp bạn hiểu rõ hơn về khái niệm re-org và cách đối phó với nó trong backend.\nCảm ơn mọi người đã đọc tới đây. Hẹn gặp lại ở bài viết tiếp theo nhé! 🚀\n","permalink":"https://thanhhv.github.io/posts/reorg-in-blockchain/","summary":"\u003ch2 id=\"1-cơ-bản-về-cách-blockchain-thêm-block\"\u003e1. Cơ bản về cách blockchain thêm block\u003c/h2\u003e\n\u003cp\u003eCác blockchain như Ethereum, Bitcoin hoạt động như sau:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại.\u003c/li\u003e\n\u003cli\u003eKhi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng.\u003c/li\u003e\n\u003cli\u003eCác node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.\u003cbr\u003e\nGiả sử mạng lưới đang dừng ở block thứ \u003ccode\u003e99\u003c/code\u003e. Miner A tìm ra block \u003ccode\u003e100A\u003c/code\u003e và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block \u003ccode\u003e100B\u003c/code\u003e và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.\u003c/p\u003e","title":"Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain \"đổi ý\""},{"content":"Xin chào các bạn,\nTrong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là SQL và NoSQL, cụ thể là PostgreSQL và MongoDB. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.\nTôi có thể khẳng định ngay từ đầu rằng không có loại cơ sở dữ liệu nào là \u0026ldquo;tốt nhất\u0026rdquo;, mà chỉ có loại phù hợp nhất với bối cảnh và yêu cầu của dự án tại thời điểm đó.\n1. Tính linh hoạt và yêu cầu thay đổi Nếu dự án có deadline gấp, trong khi yêu cầu nghiệp vụ hoặc schema dữ liệu còn mơ hồ và dễ thay đổi liên tục, tôi sẽ ưu tiên sử dụng NoSQL, cụ thể là MongoDB.\nLý do là vì MongoDB không yêu cầu schema cố định, cho phép thay đổi cấu trúc dữ liệu linh hoạt mà không cần thực hiện các bước migration phức tạp như với cơ sở dữ liệu quan hệ. Điều này giúp tiết kiệm đáng kể thời gian và công sức trong giai đoạn phát triển ban đầu.\n2. Tính ổn định, toàn vẹn dữ liệu và nghiệp vụ phức tạp Ngược lại, nếu dự án đòi hỏi tính toàn vẹn dữ liệu cao, chẳng hạn như các hệ thống tài chính, ngân hàng hoặc thương mại điện tử, thì tôi sẽ ưu tiên sử dụng SQL, như PostgreSQL.\nPostgreSQL hỗ trợ ACID tốt, xử lý tốt các mối quan hệ phức tạp, kể cả khi sử dụng dữ liệu JSON, mà vẫn đảm bảo hiệu năng. Cấu trúc dữ liệu rõ ràng, chặt chẽ giúp dễ dàng phát hiện và ngăn chặn lỗi logic từ sớm.\nNgược lại, MongoDB lại quá linh hoạt, điều này tiềm ẩn nhiều rủi ro nếu dev không kiểm soát tốt. Tôi từng gặp trường hợp trong một dự án mà nhiều team cùng sử dụng chung một MongoDB instance. Mỗi team lại định nghĩa collection Users theo cách riêng, với các field khác nhau — dẫn đến việc khó bảo trì, khó hiểu dữ liệu, và dễ phát sinh lỗi khó debug.\n3. Nguồn lực và năng lực của team Bên cạnh yêu cầu kỹ thuật, chúng ta cũng cần xem xét năng lực của team backend và team DevOps trong việc triển khai và vận hành hệ thống.\nNếu team đã quen sử dụng PostgreSQL hoặc có kinh nghiệm xử lý dữ liệu phức tạp, thì PostgreSQL sẽ là lựa chọn hiệu quả hơn. Nếu team mạnh về Node.js, JavaScript, và đã quen dùng Mongoose, thì có thể cân nhắc sử dụng MongoDB nếu phù hợp với yêu cầu dự án. Trong trường hợp nguồn lực hạn chế, chưa thể đầu tư cho một loại database mới, thì có thể tạm thời sử dụng giải pháp hiện tại, nhưng cần có kế hoạch cho việc chuyển đổi sau này, ví dụ như áp dụng Repository Pattern để tách biệt phần logic truy cập cơ sở dữ liệu khỏi business logic. 4. Tổng kết Tôi thường không chọn database theo cảm tính hay thói quen, mà sẽ đánh giá dựa trên các tiêu chí:\nYêu cầu nghiệp vụ Tính chất dữ liệu Deadline triển khai Năng lực đội ngũ kỹ thuật Tôi không tin vào “công nghệ tốt nhất”, mà tin vào “công nghệ phù hợp nhất với bài toán cụ thể tại thời điểm cụ thể”.\n","permalink":"https://thanhhv.github.io/posts/mongodb-vs-postgresql/","summary":"\u003cp\u003eXin chào các bạn,\u003c/p\u003e\n\u003cp\u003eTrong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là \u003cstrong\u003eSQL\u003c/strong\u003e và \u003cstrong\u003eNoSQL\u003c/strong\u003e, cụ thể là \u003cstrong\u003ePostgreSQL\u003c/strong\u003e và \u003cstrong\u003eMongoDB\u003c/strong\u003e. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.\u003c/p\u003e","title":"SQL vs NoSQL"},{"content":"🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at thanhhv.github.io. Stay tuned for more!\n","permalink":"https://thanhhv.github.io/posts/welcome/","summary":"\u003cp\u003e🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at \u003cstrong\u003ethanhhv.github.io\u003c/strong\u003e. Stay tuned for more!\u003c/p\u003e","title":"Welcome"},{"content":"👨‍💻 Hoang Van Thanh - Backend Engineer 📍 Thu Duc, Ho Chi Minh City, Vietnam 📞 0332 *** 362 📧 Email: thanhhv317@gmail.com 🐙 GitHub: @thanhhv 🔗 LinkedIn: linkedin.com/in/thanhhv317 📅 DOB: 11/08/1998 🛠 Skills Languages \u0026amp; Frameworks: Node.js, Go, TypeScript, JavaScript, Express, NestJS Architecture: Microservices, Message Queue, Clean Architecture, WebSocket Databases: MongoDB, PostgreSQL, Redis Blockchain: Web3.js, ethers, On-chain Data DevOps \u0026amp; Tools: Docker, AWS (EC2, S3, Lambda, SQS), Prometheus, Grafana, Kibana Testing \u0026amp; Monitoring: Jest, Jaeger, Tracing, n8n Others: HTML, CSS, Bootstrap, React.js, CI/CD, GitHub, Linux Soft Skills: Problem solving, Teamwork Languages: English 💼 Experience Coin98 (9/2023 - 4/2025) Project: AmberBlocks - Blockchain CMS platform\nDesigned databases for tags, courses, series, etc. Implemented Meilisearch for full-text search Developed services for core business logic Wrote unit tests and participated in agile sprints Project: OneID \u0026amp; KYC - Blockchain-based identity solution\nDesigned databases and handled smart contract integration Built modules for KYC/KYB and payment tracking Project: Superwallet Market Service\nMigrated JS → TS, refactored services Integrated CoinGecko and Debank APIs Provided analytics and market tracking Finviet Technology Corporation (10/2020 - 9/2023) Project: Loyalty - Scalable system for transaction-based point rewards\nArchitected databases and microservices Integrated monitoring with Prometheus \u0026amp; Grafana Wrote dashboards and optimized MongoDB queries Project: Eco Consumer App\nBuilt backend for wallet, loyalty, payments Integrated WebSocket and third-party services Generated business reports and system schedulers Project: Eco CMS Service\nIntegrated bill payment and refactored backend logic Eplus Solution \u0026amp; Technology (5/2019 - 9/2020) Internship → Fresher Developer\nBuilt backend using Go and Node.js Participated in Agile development, unit testing Helped with HTML-to-PDF extraction and frontend integration 🎓 Education Ho Chi Minh University of Education (2016 - 2020)\nFaculty of Information Technology\n🎯 About Me I\u0026rsquo;m a passionate backend developer seeking opportunities to grow, contribute, and build scalable, secure, and impactful systems - especially in Web3 and cloud-based platforms. I love learning system design, building microservices, and optimizing infrastructure.\n📂 Projects \u0026amp; Links Blog: thanhhv.github.io GitHub: thanhhv Last updated: 2024-04-23\n","permalink":"https://thanhhv.github.io/cv/","summary":"\u003ch2 id=\"-hoang-van-thanh---backend-engineer\"\u003e👨‍💻 Hoang Van Thanh - Backend Engineer\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e📍 Thu Duc, Ho Chi Minh City, Vietnam\u003c/li\u003e\n\u003cli\u003e📞 0332 *** 362\u003c/li\u003e\n\u003cli\u003e📧 Email: \u003ca href=\"mailto:thanhhv317@gmail.com\"\u003ethanhhv317@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e🐙 GitHub: \u003ca href=\"https://github.com/thanhhv\"\u003e@thanhhv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e🔗 LinkedIn: \u003ca href=\"https://www.linkedin.com/in/thanhhv317/\"\u003elinkedin.com/in/thanhhv317\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e📅 DOB: 11/08/1998\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"-skills\"\u003e🛠 Skills\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages \u0026amp; Frameworks\u003c/strong\u003e: Node.js, Go, TypeScript, JavaScript, Express, NestJS\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eArchitecture\u003c/strong\u003e: Microservices, Message Queue, Clean Architecture, WebSocket\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDatabases\u003c/strong\u003e: MongoDB, PostgreSQL, Redis\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBlockchain\u003c/strong\u003e: Web3.js, ethers, On-chain Data\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDevOps \u0026amp; Tools\u003c/strong\u003e: Docker, AWS (EC2, S3, Lambda, SQS), Prometheus, Grafana, Kibana\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTesting \u0026amp; Monitoring\u003c/strong\u003e: Jest, Jaeger, Tracing, n8n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOthers\u003c/strong\u003e: HTML, CSS, Bootstrap, React.js, CI/CD, GitHub, Linux\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSoft Skills\u003c/strong\u003e: Problem solving, Teamwork\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages\u003c/strong\u003e: English\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"-experience\"\u003e💼 Experience\u003c/h3\u003e\n\u003ch4 id=\"coin98-92023---42025\"\u003eCoin98 (9/2023 - 4/2025)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eProject: AmberBlocks\u003c/strong\u003e - Blockchain CMS platform\u003c/p\u003e","title":"Curriculum Vitae"},{"content":" 🎯 Goal: Ensure the system is stable, scalable, and production-ready before launching.\n🧱 I. CODE \u0026amp; FUNCTIONAL Code reviewed and approved by at least one senior developer Unit test coverage ≥ 80% Edge cases handled properly No N+1 queries (GraphQL/ORM optimized) No leftover console.log or debugger in code No secrets or tokens hardcoded 🚦 II. CI/CD \u0026amp; DEPLOYMENT CI pipeline set up (build → test → deploy) Rollback plan in place (script or quick revert strategy) Staging/UAT environment available and tested .env variables configured correctly (not copied from local) Proper branch/tag naming (e.g. release/v1.0.0) 🔒 III. SECURITY Auth applied on all sensitive routes (JWT, OAuth, API keys) Role \u0026amp; permission system tested No publicly exposed sensitive endpoints (/admin, /debug) Checked for XSS, SQLi, path traversal vulnerabilities Rate limiting/throttling in place for public APIs Security headers enabled (helmet, CORS, etc.) 📈 IV. PERFORMANCE \u0026amp; SCALING Load tested for target RPS (e.g. ≥ 10k req/s) Concurrent users simulated (e.g. 1k logins) DB indexed properly (EXPLAIN ANALYZE used) Redis, CDN, or in-memory caching applied File/media offloaded to external storage (e.g. S3) API only returns necessary data (REST/GraphQL select) 🧠 V. MONITORING \u0026amp; ALERTING Logging integrated (Winston, Pino, ELK, Datadog, etc.) Logs include traceId, userId, route context Metrics collection: Prometheus / Grafana / OpenTelemetry Alert configured for: High error rate (5xx) CPU \u0026gt; 80% Memory full Queue backlog increasing ⚙️ VI. INFRASTRUCTURE Load balancer configured and stable Auto-restart and healthcheck ready (PM2, Docker, k8s readiness) Database backup and restore tested Horizontal scaling/pod autoscaling set up if using k8s .env.production encrypted or managed via Vault 📋 VII. OTHER Changelog written (CHANGELOG.md) Release announcement sent to relevant teams Post-deploy checklist created (Smoke test UI/API) QA checklist completed (login, checkout, error, etc.) Graceful fallback UI for error handling /status, /health, /metrics, /version endpoints ready ✅ READY TO GO LIVE? Goal Ready? Code clean and stable ✅ Load test passed ✅ Monitoring in place ✅ Rollback plan confirmed ✅ Stakeholders notified ✅ 🔁 POST GO-LIVE ACTIONS Real-time system monitoring active User feedback monitored Latency/error rate observed 24h go-live report or postmortem (if needed) ","permalink":"https://thanhhv.github.io/wiki/go-live-checklist/","summary":"\u003cblockquote\u003e\n\u003cp\u003e🎯 \u003cstrong\u003eGoal:\u003c/strong\u003e Ensure the system is stable, scalable, and production-ready before launching.\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-i-code--functional\"\u003e🧱 I. CODE \u0026amp; FUNCTIONAL\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Code reviewed and approved by at least one senior developer\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Unit test coverage ≥ 80%\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Edge cases handled properly\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No N+1 queries (GraphQL/ORM optimized)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No leftover \u003ccode\u003econsole.log\u003c/code\u003e or \u003ccode\u003edebugger\u003c/code\u003e in code\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No secrets or tokens hardcoded\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-ii-cicd--deployment\"\u003e🚦 II. CI/CD \u0026amp; DEPLOYMENT\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e CI pipeline set up (build → test → deploy)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Rollback plan in place (script or quick revert strategy)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Staging/UAT environment available and tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e.env\u003c/code\u003e variables configured correctly (not copied from local)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Proper branch/tag naming (e.g. \u003ccode\u003erelease/v1.0.0\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-iii-security\"\u003e🔒 III. SECURITY\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Auth applied on all sensitive routes (JWT, OAuth, API keys)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Role \u0026amp; permission system tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No publicly exposed sensitive endpoints (\u003ccode\u003e/admin\u003c/code\u003e, \u003ccode\u003e/debug\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Checked for XSS, SQLi, path traversal vulnerabilities\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Rate limiting/throttling in place for public APIs\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Security headers enabled (\u003ccode\u003ehelmet\u003c/code\u003e, CORS, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-iv-performance--scaling\"\u003e📈 IV. PERFORMANCE \u0026amp; SCALING\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Load tested for target RPS (e.g. ≥ 10k req/s)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Concurrent users simulated (e.g. 1k logins)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e DB indexed properly (\u003ccode\u003eEXPLAIN ANALYZE\u003c/code\u003e used)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Redis, CDN, or in-memory caching applied\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e File/media offloaded to external storage (e.g. S3)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e API only returns necessary data (REST/GraphQL select)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-v-monitoring--alerting\"\u003e🧠 V. MONITORING \u0026amp; ALERTING\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Logging integrated (Winston, Pino, ELK, Datadog, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Logs include traceId, userId, route context\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Metrics collection: Prometheus / Grafana / OpenTelemetry\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Alert configured for:\n\u003cul\u003e\n\u003cli\u003eHigh error rate (5xx)\u003c/li\u003e\n\u003cli\u003eCPU \u0026gt; 80%\u003c/li\u003e\n\u003cli\u003eMemory full\u003c/li\u003e\n\u003cli\u003eQueue backlog increasing\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-vi-infrastructure\"\u003e⚙️ VI. INFRASTRUCTURE\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Load balancer configured and stable\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Auto-restart and healthcheck ready (PM2, Docker, k8s readiness)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Database backup and restore tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Horizontal scaling/pod autoscaling set up if using k8s\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e.env.production\u003c/code\u003e encrypted or managed via Vault\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-vii-other\"\u003e📋 VII. OTHER\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Changelog written (\u003ccode\u003eCHANGELOG.md\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Release announcement sent to relevant teams\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Post-deploy checklist created (Smoke test UI/API)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e QA checklist completed (login, checkout, error, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Graceful fallback UI for error handling\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e/status\u003c/code\u003e, \u003ccode\u003e/health\u003c/code\u003e, \u003ccode\u003e/metrics\u003c/code\u003e, \u003ccode\u003e/version\u003c/code\u003e endpoints ready\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-ready-to-go-live\"\u003e✅ READY TO GO LIVE?\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eGoal\u003c/th\u003e\n          \u003cth\u003eReady?\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCode clean and stable\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eLoad test passed\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMonitoring in place\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRollback plan confirmed\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eStakeholders notified\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"-post-go-live-actions\"\u003e🔁 POST GO-LIVE ACTIONS\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Real-time system monitoring active\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e User feedback monitored\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Latency/error rate observed\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 24h go-live report or postmortem (if needed)\u003c/li\u003e\n\u003c/ul\u003e","title":"Go-live load test \u0026 deployment checklist"},{"content":"Reading is not only for fun, but also to develop clear thinking and deeper perspective.\nHere\u0026rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.\n📘 Psychology \u0026amp; Thinking Thinking, Fast and Slow - Daniel Kahneman The One Thing - Gary W. Keller, Jay Papasan 🌍 Philosophy \u0026amp; Life Naval Ravikant: Để thịnh vượng và hạnh phúc - Eric Jorgenson \u0026hellip; will be updated more\n","permalink":"https://thanhhv.github.io/wiki/non-tech-books-worth-reading/","summary":"\u003cp\u003eReading is not only for fun, but also to develop clear thinking and deeper perspective.\u003cbr\u003e\nHere\u0026rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.\u003c/p\u003e\n\u003ch2 id=\"-psychology--thinking\"\u003e📘 Psychology \u0026amp; Thinking\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eThinking, Fast and Slow\u003c/em\u003e - Daniel Kahneman\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eThe One Thing\u003c/em\u003e - Gary W. Keller, Jay Papasan\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"-philosophy--life\"\u003e🌍 Philosophy \u0026amp; Life\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eNaval Ravikant: Để thịnh vượng và hạnh phúc\u003c/em\u003e - Eric Jorgenson\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026hellip; will be updated more\u003c/p\u003e","title":"Non-Tech Books Worth Reading"}]
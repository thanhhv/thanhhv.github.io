[{"content":"Hôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,\u0026hellip;). Cùng bắt đầu nhé! Quá trình này gồm 3 bước đơn giản:\n1. Lấy message từ server Đầu tiên, client sẽ gửi request đến server để lấy message về. Đây là nội dung mà client sẽ ký bằng ví như Metamask để xác thực với dApp.\nVì message cần được thống nhất giữa server và client, nên server nên là bên tạo và quản lý message này.\nVí dụ message: thanhhv.github.io wants you to sign in with your Ethereum account: 0xA1B2...D3E4 Sign-in request for MyDApp URI: https://thanhhv.github.io Version: 1 Chain ID: 1 Nonce: 839174 Issued At: 2025-05-11T20:40:00Z Đây là định dạng theo EIP-4361 (Sign-In With Ethereum) được sử dụng phổ biến.\nNonce là số ngẫu nhiên dùng một lần (có thể dùng UUID), kết hợp với timestamp để tránh replay attack.\nServer nên tạo nonce, lưu vào database với các field:\nnonce, wallet, expiresAt, used = false, sau đó gắn vào message trả về cho client.\n2. Client ký message bằng private key Sau khi nhận được message, client sẽ dùng private key để ký.\nVí dụ sử dụng thư viện ethers:\nconst { ethers } = require(\u0026#34;ethers\u0026#34;); const wallet = new ethers.Wallet(process.env.PRIVATE_KEY); const signature = await wallet.signMessage(message); Client sau đó gửi { message, signature } về server.\n3. Server xác thực chữ ký Server sẽ:\nTách nonce từ message ra. Truy vấn DB để kiểm tra: Có tồn tại không? Hết hạn chưa? Đã được sử dụng chưa? Sau đó, dùng ethers để xác thực chữ ký:\nconst { ethers } = require(\u0026#34;ethers\u0026#34;); const recoveredAddress = ethers.utils.verifyMessage(message, signature); const isValid = recoveredAddress.toLowerCase() === addressFromRequest; Nếu hợp lệ, server có thể cập nhật DB: used = true, và cho phép đăng nhập thành công.\n4. Bonus: Kết hợp với JWT Giả sử bạn đang xây dựng trang quản trị admin, sau khi bước 3 hoàn tất, server có thể tạo 1 JWT token. Những request tiếp theo sẽ dùng token này để xác thực — giống như mô hình web2 quen thuộc.\nTuy là đăng nhập bằng ví crypto, nhưng sau đó bạn có thể tương tác với hệ thống như người dùng thông thường, vừa an toàn, vừa tiện lợi.\nHết rồi! Hy vọng bài viết hữu ích cho bạn nào đang tìm hiểu về Web3 authentication. Chúc cho tôi sẽ may mắn vượt qua vòng phỏng vấn sắp tới nhé, hihi 😄\n","permalink":"https://thanhhv.github.io/posts/verify-user-wallet/","summary":"\u003cp\u003eHôm nay, trong một buổi đầu tuần sau chuyến đi du lịch giữa năm, tôi tranh thủ ôn lại kiến thức để chuẩn bị cho buổi phỏng vấn vị trí Backend Blockchain sắp tới. Nhân tiện, tôi viết lại bài này để ghi nhớ kỹ thuật xác thực người dùng không cần tài khoản và mật khẩu, mà sử dụng đăng nhập bằng ví Web3 (như Metamask, Coin98 Super Wallet, Trust Wallet,\u0026hellip;). Cùng bắt đầu nhé! Quá trình này gồm \u003cstrong\u003e3 bước đơn giản\u003c/strong\u003e:\u003c/p\u003e","title":"Xác thực người dùng bằng ví crypto"},{"content":"1. Cơ bản về cách blockchain thêm block Các blockchain như Ethereum, Bitcoin hoạt động như sau:\nMỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại. Khi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng. Các node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình. Vấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.\nGiả sử mạng lưới đang dừng ở block thứ 99. Miner A tìm ra block 100A và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block 100B và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.\nLúc này, blockchain tạo ra hai nhánh tạm thời (gọi là temporary fork) ở block thứ 100.\n2. Khi nào xảy ra re-org? Giả sử Miner C đào tiếp block 101 dựa trên 100B, chuỗi lúc này là:\nBlock 99 -\u0026gt; Block 100B -\u0026gt; Block 101 Trong khi đó, bạn đang theo chuỗi:\nBlock 99 -\u0026gt; Block 100A Theo quy tắc longest chain, blockchain sẽ chọn chuỗi dài hơn là chuỗi chính thức.\nVì vậy, chain 100B -\u0026gt; 101 sẽ được chấp nhận, và block 100A bị loại bỏ.\nQuá trình này gọi là chain reorganization (re-org).\nRe-org là lúc mà mạng đổi ý và chọn một nhánh mới dài hơn, bỏ qua nhánh cũ — giống như chơi cờ mà bỗng dưng đi lại nước trước đó vì thấy đường khác ngon hơn!\n3. Các kỹ thuật xử lý khi re-org xảy ra ở phía backend 3.1. Delay block confirmation Đây là cách phổ biến và đơn giản nhất.\nKhi indexing dữ liệu từ blockchain, bạn bỏ qua một vài block cuối cùng để tránh sai sót do re-org.\nVí dụ:\nTrên Ethereum, thường bỏ qua 12 block cuối (tức chỉ xử lý đến latest - 12). Các chain khác sẽ có con số riêng, bạn cần tra thêm tài liệu. Tuy nhiên, cách này có độ trễ nên có thể kèm theo giải pháp UI như:\n\u0026ldquo;Đang xử lý dữ liệu\u0026hellip; lần cập nhật gần nhất 1 phút trước\u0026rdquo;\n3.2. Xây dựng hệ thống rollback tự động (phức tạp hơn) Để dữ liệu gần như realtime nhưng vẫn chính xác, bạn có thể xây hệ thống hỗ trợ rollback khi re-org:\nKhi lưu dữ liệu từ block, luôn lưu kèm blockNumber và blockHash. Mỗi khi có block mới, kiểm tra lại N block trước đó (ví dụ: 12 block). Nếu blockHash không khớp với dữ liệu đã lưu: Rollback: xóa dữ liệu liên quan block cũ, sync lại block mới. Hoặc tạo record mới với trạng thái như: confirmed, reorged, replaced,\u0026hellip; để phục vụ audit. Phương pháp này chính xác hơn, nhưng phức tạp và tốn công hơn rất nhiều.\nViệc lựa chọn cách xử lý phù hợp nên linh hoạt tùy vào yêu cầu hệ thống và đặc thù sản phẩm bạn đang làm.\n👋 Kết Hy vọng bài viết giúp bạn hiểu rõ hơn về khái niệm re-org và cách đối phó với nó trong backend.\nCảm ơn mọi người đã đọc tới đây. Hẹn gặp lại ở bài viết tiếp theo nhé! 🚀\n","permalink":"https://thanhhv.github.io/posts/reorg-in-blockchain/","summary":"\u003ch2 id=\"1-cơ-bản-về-cách-blockchain-thêm-block\"\u003e1. Cơ bản về cách blockchain thêm block\u003c/h2\u003e\n\u003cp\u003eCác blockchain như Ethereum, Bitcoin hoạt động như sau:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMỗi node trong mạng sẽ giữ một bản sao của blockchain hiện tại.\u003c/li\u003e\n\u003cli\u003eKhi một miner (hoặc validator) tìm được block mới hợp lệ, nó sẽ broadcast block đó cho mạng.\u003c/li\u003e\n\u003cli\u003eCác node nhận block mới sẽ xác minh, nếu hợp lệ thì thêm vào chain của mình.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVấn đề xảy ra khi nhiều miner có thể tìm được block mới gần như cùng một lúc.\u003cbr\u003e\nGiả sử mạng lưới đang dừng ở block thứ \u003ccode\u003e99\u003c/code\u003e. Miner A tìm ra block \u003ccode\u003e100A\u003c/code\u003e và broadcast nó. Ở một nơi khác, Miner B cũng tìm ra một block \u003ccode\u003e100B\u003c/code\u003e và broadcast. Do độ trễ mạng, các node khác nhau có thể nhận và thêm vào chuỗi khác nhau: 100A hoặc 100B.\u003c/p\u003e","title":"Re-org là gì? Backend Developer cần xử lý thế nào khi Blockchain \"đổi ý\""},{"content":"Xin chào các bạn,\nTrong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là SQL và NoSQL, cụ thể là PostgreSQL và MongoDB. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.\nTôi có thể khẳng định ngay từ đầu rằng không có loại cơ sở dữ liệu nào là \u0026ldquo;tốt nhất\u0026rdquo;, mà chỉ có loại phù hợp nhất với bối cảnh và yêu cầu của dự án tại thời điểm đó.\n1. Tính linh hoạt và yêu cầu thay đổi Nếu dự án có deadline gấp, trong khi yêu cầu nghiệp vụ hoặc schema dữ liệu còn mơ hồ và dễ thay đổi liên tục, tôi sẽ ưu tiên sử dụng NoSQL, cụ thể là MongoDB.\nLý do là vì MongoDB không yêu cầu schema cố định, cho phép thay đổi cấu trúc dữ liệu linh hoạt mà không cần thực hiện các bước migration phức tạp như với cơ sở dữ liệu quan hệ. Điều này giúp tiết kiệm đáng kể thời gian và công sức trong giai đoạn phát triển ban đầu.\n2. Tính ổn định, toàn vẹn dữ liệu và nghiệp vụ phức tạp Ngược lại, nếu dự án đòi hỏi tính toàn vẹn dữ liệu cao, chẳng hạn như các hệ thống tài chính, ngân hàng hoặc thương mại điện tử, thì tôi sẽ ưu tiên sử dụng SQL, như PostgreSQL.\nPostgreSQL hỗ trợ ACID tốt, xử lý tốt các mối quan hệ phức tạp, kể cả khi sử dụng dữ liệu JSON, mà vẫn đảm bảo hiệu năng. Cấu trúc dữ liệu rõ ràng, chặt chẽ giúp dễ dàng phát hiện và ngăn chặn lỗi logic từ sớm.\nNgược lại, MongoDB lại quá linh hoạt, điều này tiềm ẩn nhiều rủi ro nếu dev không kiểm soát tốt. Tôi từng gặp trường hợp trong một dự án mà nhiều team cùng sử dụng chung một MongoDB instance. Mỗi team lại định nghĩa collection Users theo cách riêng, với các field khác nhau — dẫn đến việc khó bảo trì, khó hiểu dữ liệu, và dễ phát sinh lỗi khó debug.\n3. Nguồn lực và năng lực của team Bên cạnh yêu cầu kỹ thuật, chúng ta cũng cần xem xét năng lực của team backend và team DevOps trong việc triển khai và vận hành hệ thống.\nNếu team đã quen sử dụng PostgreSQL hoặc có kinh nghiệm xử lý dữ liệu phức tạp, thì PostgreSQL sẽ là lựa chọn hiệu quả hơn. Nếu team mạnh về Node.js, JavaScript, và đã quen dùng Mongoose, thì có thể cân nhắc sử dụng MongoDB nếu phù hợp với yêu cầu dự án. Trong trường hợp nguồn lực hạn chế, chưa thể đầu tư cho một loại database mới, thì có thể tạm thời sử dụng giải pháp hiện tại, nhưng cần có kế hoạch cho việc chuyển đổi sau này, ví dụ như áp dụng Repository Pattern để tách biệt phần logic truy cập cơ sở dữ liệu khỏi business logic. 4. Tổng kết Tôi thường không chọn database theo cảm tính hay thói quen, mà sẽ đánh giá dựa trên các tiêu chí:\nYêu cầu nghiệp vụ Tính chất dữ liệu Deadline triển khai Năng lực đội ngũ kỹ thuật Tôi không tin vào “công nghệ tốt nhất”, mà tin vào “công nghệ phù hợp nhất với bài toán cụ thể tại thời điểm cụ thể”.\n","permalink":"https://thanhhv.github.io/posts/mongodb-vs-postgresql/","summary":"\u003cp\u003eXin chào các bạn,\u003c/p\u003e\n\u003cp\u003eTrong bài viết này, tôi sẽ chia sẻ một số kinh nghiệm cá nhân khi phải lựa chọn giữa hai loại cơ sở dữ liệu phổ biến là \u003cstrong\u003eSQL\u003c/strong\u003e và \u003cstrong\u003eNoSQL\u003c/strong\u003e, cụ thể là \u003cstrong\u003ePostgreSQL\u003c/strong\u003e và \u003cstrong\u003eMongoDB\u003c/strong\u003e. Bài viết không đi sâu vào lý thuyết SQL hay NoSQL là gì, mà sẽ tập trung vào góc nhìn thực tế khi phải đưa ra lựa chọn trong một dự án cụ thể.\u003c/p\u003e","title":"SQL vs NoSQL"},{"content":"🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at thanhhv.github.io. Stay tuned for more!\n","permalink":"https://thanhhv.github.io/posts/welcome/","summary":"\u003cp\u003e🚀 This is the beginning of my Hugo + PaperMod powered blog hosted at \u003cstrong\u003ethanhhv.github.io\u003c/strong\u003e. Stay tuned for more!\u003c/p\u003e","title":"Welcome"},{"content":"👨‍💻 Hoang Van Thanh - Backend Engineer 📍 Thu Duc, Ho Chi Minh City, Vietnam 📞 0332 *** 362 📧 Email: thanhhv317@gmail.com 🐙 GitHub: @thanhhv 🔗 LinkedIn: linkedin.com/in/thanhhv317 📅 DOB: 11/08/1998 🛠 Skills Languages \u0026amp; Frameworks: Node.js, Go, TypeScript, JavaScript, Express, NestJS Architecture: Microservices, Message Queue, Clean Architecture, WebSocket Databases: MongoDB, PostgreSQL, Redis Blockchain: Web3.js, ethers, On-chain Data DevOps \u0026amp; Tools: Docker, AWS (EC2, S3, Lambda, SQS), Prometheus, Grafana, Kibana Testing \u0026amp; Monitoring: Jest, Jaeger, Tracing, n8n Others: HTML, CSS, Bootstrap, React.js, CI/CD, GitHub, Linux Soft Skills: Problem solving, Teamwork Languages: English 💼 Experience Coin98 (9/2023 - 4/2025) Project: AmberBlocks - Blockchain CMS platform\nDesigned databases for tags, courses, series, etc. Implemented Meilisearch for full-text search Developed services for core business logic Wrote unit tests and participated in agile sprints Project: OneID \u0026amp; KYC - Blockchain-based identity solution\nDesigned databases and handled smart contract integration Built modules for KYC/KYB and payment tracking Project: Superwallet Market Service\nMigrated JS → TS, refactored services Integrated CoinGecko and Debank APIs Provided analytics and market tracking Finviet Technology Corporation (10/2020 - 9/2023) Project: Loyalty - Scalable system for transaction-based point rewards\nArchitected databases and microservices Integrated monitoring with Prometheus \u0026amp; Grafana Wrote dashboards and optimized MongoDB queries Project: Eco Consumer App\nBuilt backend for wallet, loyalty, payments Integrated WebSocket and third-party services Generated business reports and system schedulers Project: Eco CMS Service\nIntegrated bill payment and refactored backend logic Eplus Solution \u0026amp; Technology (5/2019 - 9/2020) Internship → Fresher Developer\nBuilt backend using Go and Node.js Participated in Agile development, unit testing Helped with HTML-to-PDF extraction and frontend integration 🎓 Education Ho Chi Minh University of Education (2016 - 2020)\nFaculty of Information Technology\n🎯 About Me I\u0026rsquo;m a passionate backend developer seeking opportunities to grow, contribute, and build scalable, secure, and impactful systems - especially in Web3 and cloud-based platforms. I love learning system design, building microservices, and optimizing infrastructure.\n📂 Projects \u0026amp; Links Blog: thanhhv.github.io GitHub: thanhhv Last updated: 2024-04-23\n","permalink":"https://thanhhv.github.io/cv/","summary":"\u003ch2 id=\"-hoang-van-thanh---backend-engineer\"\u003e👨‍💻 Hoang Van Thanh - Backend Engineer\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e📍 Thu Duc, Ho Chi Minh City, Vietnam\u003c/li\u003e\n\u003cli\u003e📞 0332 *** 362\u003c/li\u003e\n\u003cli\u003e📧 Email: \u003ca href=\"mailto:thanhhv317@gmail.com\"\u003ethanhhv317@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e🐙 GitHub: \u003ca href=\"https://github.com/thanhhv\"\u003e@thanhhv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e🔗 LinkedIn: \u003ca href=\"https://www.linkedin.com/in/thanhhv317/\"\u003elinkedin.com/in/thanhhv317\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e📅 DOB: 11/08/1998\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"-skills\"\u003e🛠 Skills\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages \u0026amp; Frameworks\u003c/strong\u003e: Node.js, Go, TypeScript, JavaScript, Express, NestJS\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eArchitecture\u003c/strong\u003e: Microservices, Message Queue, Clean Architecture, WebSocket\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDatabases\u003c/strong\u003e: MongoDB, PostgreSQL, Redis\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBlockchain\u003c/strong\u003e: Web3.js, ethers, On-chain Data\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDevOps \u0026amp; Tools\u003c/strong\u003e: Docker, AWS (EC2, S3, Lambda, SQS), Prometheus, Grafana, Kibana\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTesting \u0026amp; Monitoring\u003c/strong\u003e: Jest, Jaeger, Tracing, n8n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOthers\u003c/strong\u003e: HTML, CSS, Bootstrap, React.js, CI/CD, GitHub, Linux\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSoft Skills\u003c/strong\u003e: Problem solving, Teamwork\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages\u003c/strong\u003e: English\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"-experience\"\u003e💼 Experience\u003c/h3\u003e\n\u003ch4 id=\"coin98-92023---42025\"\u003eCoin98 (9/2023 - 4/2025)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eProject: AmberBlocks\u003c/strong\u003e - Blockchain CMS platform\u003c/p\u003e","title":"Curriculum Vitae"},{"content":" 🎯 Goal: Ensure the system is stable, scalable, and production-ready before launching.\n🧱 I. CODE \u0026amp; FUNCTIONAL Code reviewed and approved by at least one senior developer Unit test coverage ≥ 80% Edge cases handled properly No N+1 queries (GraphQL/ORM optimized) No leftover console.log or debugger in code No secrets or tokens hardcoded 🚦 II. CI/CD \u0026amp; DEPLOYMENT CI pipeline set up (build → test → deploy) Rollback plan in place (script or quick revert strategy) Staging/UAT environment available and tested .env variables configured correctly (not copied from local) Proper branch/tag naming (e.g. release/v1.0.0) 🔒 III. SECURITY Auth applied on all sensitive routes (JWT, OAuth, API keys) Role \u0026amp; permission system tested No publicly exposed sensitive endpoints (/admin, /debug) Checked for XSS, SQLi, path traversal vulnerabilities Rate limiting/throttling in place for public APIs Security headers enabled (helmet, CORS, etc.) 📈 IV. PERFORMANCE \u0026amp; SCALING Load tested for target RPS (e.g. ≥ 10k req/s) Concurrent users simulated (e.g. 1k logins) DB indexed properly (EXPLAIN ANALYZE used) Redis, CDN, or in-memory caching applied File/media offloaded to external storage (e.g. S3) API only returns necessary data (REST/GraphQL select) 🧠 V. MONITORING \u0026amp; ALERTING Logging integrated (Winston, Pino, ELK, Datadog, etc.) Logs include traceId, userId, route context Metrics collection: Prometheus / Grafana / OpenTelemetry Alert configured for: High error rate (5xx) CPU \u0026gt; 80% Memory full Queue backlog increasing ⚙️ VI. INFRASTRUCTURE Load balancer configured and stable Auto-restart and healthcheck ready (PM2, Docker, k8s readiness) Database backup and restore tested Horizontal scaling/pod autoscaling set up if using k8s .env.production encrypted or managed via Vault 📋 VII. OTHER Changelog written (CHANGELOG.md) Release announcement sent to relevant teams Post-deploy checklist created (Smoke test UI/API) QA checklist completed (login, checkout, error, etc.) Graceful fallback UI for error handling /status, /health, /metrics, /version endpoints ready ✅ READY TO GO LIVE? Goal Ready? Code clean and stable ✅ Load test passed ✅ Monitoring in place ✅ Rollback plan confirmed ✅ Stakeholders notified ✅ 🔁 POST GO-LIVE ACTIONS Real-time system monitoring active User feedback monitored Latency/error rate observed 24h go-live report or postmortem (if needed) ","permalink":"https://thanhhv.github.io/wiki/go-live-checklist/","summary":"\u003cblockquote\u003e\n\u003cp\u003e🎯 \u003cstrong\u003eGoal:\u003c/strong\u003e Ensure the system is stable, scalable, and production-ready before launching.\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-i-code--functional\"\u003e🧱 I. CODE \u0026amp; FUNCTIONAL\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Code reviewed and approved by at least one senior developer\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Unit test coverage ≥ 80%\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Edge cases handled properly\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No N+1 queries (GraphQL/ORM optimized)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No leftover \u003ccode\u003econsole.log\u003c/code\u003e or \u003ccode\u003edebugger\u003c/code\u003e in code\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No secrets or tokens hardcoded\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-ii-cicd--deployment\"\u003e🚦 II. CI/CD \u0026amp; DEPLOYMENT\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e CI pipeline set up (build → test → deploy)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Rollback plan in place (script or quick revert strategy)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Staging/UAT environment available and tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e.env\u003c/code\u003e variables configured correctly (not copied from local)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Proper branch/tag naming (e.g. \u003ccode\u003erelease/v1.0.0\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-iii-security\"\u003e🔒 III. SECURITY\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Auth applied on all sensitive routes (JWT, OAuth, API keys)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Role \u0026amp; permission system tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e No publicly exposed sensitive endpoints (\u003ccode\u003e/admin\u003c/code\u003e, \u003ccode\u003e/debug\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Checked for XSS, SQLi, path traversal vulnerabilities\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Rate limiting/throttling in place for public APIs\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Security headers enabled (\u003ccode\u003ehelmet\u003c/code\u003e, CORS, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-iv-performance--scaling\"\u003e📈 IV. PERFORMANCE \u0026amp; SCALING\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Load tested for target RPS (e.g. ≥ 10k req/s)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Concurrent users simulated (e.g. 1k logins)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e DB indexed properly (\u003ccode\u003eEXPLAIN ANALYZE\u003c/code\u003e used)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Redis, CDN, or in-memory caching applied\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e File/media offloaded to external storage (e.g. S3)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e API only returns necessary data (REST/GraphQL select)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-v-monitoring--alerting\"\u003e🧠 V. MONITORING \u0026amp; ALERTING\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Logging integrated (Winston, Pino, ELK, Datadog, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Logs include traceId, userId, route context\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Metrics collection: Prometheus / Grafana / OpenTelemetry\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Alert configured for:\n\u003cul\u003e\n\u003cli\u003eHigh error rate (5xx)\u003c/li\u003e\n\u003cli\u003eCPU \u0026gt; 80%\u003c/li\u003e\n\u003cli\u003eMemory full\u003c/li\u003e\n\u003cli\u003eQueue backlog increasing\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-vi-infrastructure\"\u003e⚙️ VI. INFRASTRUCTURE\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Load balancer configured and stable\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Auto-restart and healthcheck ready (PM2, Docker, k8s readiness)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Database backup and restore tested\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Horizontal scaling/pod autoscaling set up if using k8s\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e.env.production\u003c/code\u003e encrypted or managed via Vault\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-vii-other\"\u003e📋 VII. OTHER\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Changelog written (\u003ccode\u003eCHANGELOG.md\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Release announcement sent to relevant teams\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Post-deploy checklist created (Smoke test UI/API)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e QA checklist completed (login, checkout, error, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Graceful fallback UI for error handling\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e \u003ccode\u003e/status\u003c/code\u003e, \u003ccode\u003e/health\u003c/code\u003e, \u003ccode\u003e/metrics\u003c/code\u003e, \u003ccode\u003e/version\u003c/code\u003e endpoints ready\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-ready-to-go-live\"\u003e✅ READY TO GO LIVE?\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eGoal\u003c/th\u003e\n          \u003cth\u003eReady?\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCode clean and stable\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eLoad test passed\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMonitoring in place\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRollback plan confirmed\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eStakeholders notified\u003c/td\u003e\n          \u003ctd\u003e✅\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"-post-go-live-actions\"\u003e🔁 POST GO-LIVE ACTIONS\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Real-time system monitoring active\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e User feedback monitored\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Latency/error rate observed\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 24h go-live report or postmortem (if needed)\u003c/li\u003e\n\u003c/ul\u003e","title":"Go-live load test \u0026 deployment checklist"},{"content":"Reading is not only for fun, but also to develop clear thinking and deeper perspective.\nHere\u0026rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.\n📘 Psychology \u0026amp; Thinking Thinking, Fast and Slow - Daniel Kahneman The One Thing - Gary W. Keller, Jay Papasan 🌍 Philosophy \u0026amp; Life Naval Ravikant: Để thịnh vượng và hạnh phúc - Eric Jorgenson \u0026hellip; will be updated more\n","permalink":"https://thanhhv.github.io/wiki/non-tech-books-worth-reading/","summary":"\u003cp\u003eReading is not only for fun, but also to develop clear thinking and deeper perspective.\u003cbr\u003e\nHere\u0026rsquo;s a list of non-technical books that can help backend engineers grow in mindset and soft skills.\u003c/p\u003e\n\u003ch2 id=\"-psychology--thinking\"\u003e📘 Psychology \u0026amp; Thinking\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eThinking, Fast and Slow\u003c/em\u003e - Daniel Kahneman\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eThe One Thing\u003c/em\u003e - Gary W. Keller, Jay Papasan\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"-philosophy--life\"\u003e🌍 Philosophy \u0026amp; Life\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eNaval Ravikant: Để thịnh vượng và hạnh phúc\u003c/em\u003e - Eric Jorgenson\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026hellip; will be updated more\u003c/p\u003e","title":"Non-Tech Books Worth Reading"}]